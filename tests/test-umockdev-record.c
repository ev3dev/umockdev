/* test-umockdev-record.c generated by valac 0.20.1, the Vala compiler
 * generated from test-umockdev-record.vala, do not modify */

/*
 * test-umockdev-record.vala
 *
 * Copyright (C) 2013 Canonical Ltd.
 * Author: Martin Pitt <martin.pitt@ubuntu.com>
 *
 * umockdev is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * umockdev is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <glib/gstdio.h>
#include <umockdev.h>
#include <unistd.h>
#include <pty.h>
#include <termios.h>
#include <sys/wait.h>
#include <sys/types.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);


extern gchar* umockdev_record_path;
gchar* umockdev_record_path = NULL;
extern gchar* rootdir;
gchar* rootdir = NULL;

void spawn (const gchar* command, gchar** sout, gchar** serr, gint* exit);
gchar* file_contents (const gchar* filename);
void t_testbed_all_empty (void);
void t_testbed_one (void);
void t_testbed_multiple (void);
void t_testbed_no_ioctl_record (void);
void t_system_all (void);
void t_system_ioctl_log (void);
void t_system_script_log_simple (void);
gchar* read_line_timeout (FILE* stream);
void t_system_script_log_chatter (void);
gint _vala_main (gchar** args, int args_length1);
static void _t_testbed_all_empty_gtest_func (void);
static void _t_testbed_one_gtest_func (void);
static void _t_testbed_multiple_gtest_func (void);
static void _t_testbed_no_ioctl_record_gtest_func (void);
static void _t_system_all_gtest_func (void);
static void _t_system_ioctl_log_gtest_func (void);
static void _t_system_script_log_simple_gtest_func (void);
static void _t_system_script_log_chatter_gtest_func (void);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


void spawn (const gchar* command, gchar** sout, gchar** serr, gint* exit) {
	gchar* _vala_sout = NULL;
	gchar* _vala_serr = NULL;
	gint _vala_exit = 0;
	GError * _inner_error_ = NULL;
	g_return_if_fail (command != NULL);
	{
		const gchar* _tmp0_;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		gboolean _tmp4_ = FALSE;
		gboolean _tmp5_;
		_tmp0_ = command;
		_tmp4_ = g_spawn_command_line_sync (_tmp0_, &_tmp1_, &_tmp2_, &_tmp3_, &_inner_error_);
		_g_free0 (_vala_sout);
		_vala_sout = _tmp1_;
		_g_free0 (_vala_serr);
		_vala_serr = _tmp2_;
		_vala_exit = _tmp3_;
		_tmp5_ = _tmp4_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_SPAWN_ERROR) {
				goto __catch0_g_spawn_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_vala_assert (_tmp5_, "Process.spawn_command_line_sync (command, out sout, out serr, out exit)");
	}
	goto __finally0;
	__catch0_g_spawn_error:
	{
		GError* e = NULL;
		FILE* _tmp6_;
		const gchar* _tmp7_;
		const gchar* _tmp8_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = stderr;
		_tmp7_ = command;
		_tmp8_ = e->message;
		fprintf (_tmp6_, "Cannot call '%s': %s\n", _tmp7_, _tmp8_);
		abort ();
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	if (sout) {
		*sout = _vala_sout;
	} else {
		_g_free0 (_vala_sout);
	}
	if (serr) {
		*serr = _vala_serr;
	} else {
		_g_free0 (_vala_serr);
	}
	if (exit) {
		*exit = _vala_exit;
	}
}


gchar* file_contents (const gchar* filename) {
	gchar* result = NULL;
	gchar* contents = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (filename != NULL, NULL);
	{
		const gchar* _tmp0_;
		gchar* _tmp1_ = NULL;
		gboolean _tmp2_ = FALSE;
		gboolean _tmp3_;
		_tmp0_ = filename;
		_tmp2_ = g_file_get_contents (_tmp0_, &_tmp1_, NULL, &_inner_error_);
		_g_free0 (contents);
		contents = _tmp1_;
		_tmp3_ = _tmp2_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch1_g_file_error;
			}
			_g_free0 (contents);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_vala_assert (_tmp3_, "FileUtils.get_contents (filename, out contents)");
	}
	goto __finally1;
	__catch1_g_file_error:
	{
		GError* e = NULL;
		FILE* _tmp4_;
		const gchar* _tmp5_;
		const gchar* _tmp6_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = stderr;
		_tmp5_ = filename;
		_tmp6_ = e->message;
		fprintf (_tmp4_, "Cannot get contents of %s: %s\n", _tmp5_, _tmp6_);
		abort ();
		_g_error_free0 (e);
	}
	__finally1:
	if (_inner_error_ != NULL) {
		_g_free0 (contents);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = contents;
	return result;
}


void t_testbed_all_empty (void) {
	gchar* sout = NULL;
	gchar* serr = NULL;
	gint exit = 0;
	UMockdevTestbed* _tmp0_;
	UMockdevTestbed* tb;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	_tmp0_ = umockdev_testbed_new ();
	tb = _tmp0_;
	_vala_assert (tb != NULL, "tb != null");
	_tmp1_ = umockdev_record_path;
	_tmp2_ = g_strconcat (_tmp1_, " --all", NULL);
	_tmp3_ = _tmp2_;
	spawn (_tmp3_, &_tmp4_, &_tmp5_, &_tmp6_);
	_g_free0 (sout);
	sout = _tmp4_;
	_g_free0 (serr);
	serr = _tmp5_;
	exit = _tmp6_;
	_g_free0 (_tmp3_);
	g_assert_cmpstr (serr, ==, "");
	g_assert_cmpstr (sout, ==, "");
	g_assert_cmpint (exit, ==, 0);
	_g_object_unref0 (tb);
	_g_free0 (serr);
	_g_free0 (sout);
}


void t_testbed_one (void) {
	gchar* sout = NULL;
	gchar* serr = NULL;
	gint exit = 0;
	UMockdevTestbed* _tmp0_;
	UMockdevTestbed* tb;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar** _tmp5_ = NULL;
	gchar** _tmp6_;
	gint _tmp6__length1;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar** _tmp9_ = NULL;
	gchar** _tmp10_;
	gint _tmp10__length1;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_;
	gchar* syspath;
	guint8* _tmp13_ = NULL;
	guint8* _tmp14_;
	gint _tmp14__length1;
	const gchar* _tmp15_;
	gchar* _tmp16_;
	gchar* _tmp17_;
	gchar* _tmp18_ = NULL;
	gchar* _tmp19_ = NULL;
	gint _tmp20_ = 0;
	_tmp0_ = umockdev_testbed_new ();
	tb = _tmp0_;
	_tmp1_ = g_strdup ("simple_attr");
	_tmp2_ = g_strdup ("1");
	_tmp3_ = g_strdup ("multiline_attr");
	_tmp4_ = g_strdup ("a\\b\nc\\d\nlast");
	_tmp5_ = g_new0 (gchar*, 4 + 1);
	_tmp5_[0] = _tmp1_;
	_tmp5_[1] = _tmp2_;
	_tmp5_[2] = _tmp3_;
	_tmp5_[3] = _tmp4_;
	_tmp6_ = _tmp5_;
	_tmp6__length1 = 4;
	_tmp7_ = g_strdup ("SIMPLE_PROP");
	_tmp8_ = g_strdup ("1");
	_tmp9_ = g_new0 (gchar*, 2 + 1);
	_tmp9_[0] = _tmp7_;
	_tmp9_[1] = _tmp8_;
	_tmp10_ = _tmp9_;
	_tmp10__length1 = 2;
	_tmp11_ = umockdev_testbed_add_devicev (tb, "pci", "dev1", NULL, _tmp6_, _tmp10_);
	_tmp12_ = _tmp11_;
	_tmp10_ = (_vala_array_free (_tmp10_, _tmp10__length1, (GDestroyNotify) g_free), NULL);
	_tmp6_ = (_vala_array_free (_tmp6_, _tmp6__length1, (GDestroyNotify) g_free), NULL);
	syspath = _tmp12_;
	_tmp13_ = g_new0 (guint8, 6);
	_tmp13_[0] = (guint8) 0x41;
	_tmp13_[1] = (guint8) 0xFF;
	_tmp13_[2] = (guint8) 0;
	_tmp13_[3] = (guint8) 5;
	_tmp13_[4] = (guint8) 0xFF;
	_tmp13_[5] = (guint8) 0;
	_tmp14_ = _tmp13_;
	_tmp14__length1 = 6;
	umockdev_testbed_set_attribute_binary (tb, syspath, "binary_attr", _tmp14_, 6);
	_tmp14_ = (g_free (_tmp14_), NULL);
	umockdev_testbed_set_attribute_link (tb, syspath, "driver", "../../drivers/foo");
	_tmp15_ = umockdev_record_path;
	_tmp16_ = g_strconcat (_tmp15_, " --all", NULL);
	_tmp17_ = _tmp16_;
	spawn (_tmp17_, &_tmp18_, &_tmp19_, &_tmp20_);
	_g_free0 (sout);
	sout = _tmp18_;
	_g_free0 (serr);
	serr = _tmp19_;
	exit = _tmp20_;
	_g_free0 (_tmp17_);
	g_assert_cmpstr (serr, ==, "");
	g_assert_cmpint (exit, ==, 0);
	g_assert_cmpstr (sout, ==, "P: /devices/dev1\n" \
"E: SIMPLE_PROP=1\n" \
"E: SUBSYSTEM=pci\n" \
"H: binary_attr=41FF0005FF00\n" \
"L: driver=../../drivers/foo\n" \
"A: multiline_attr=a\\\\b\\nc\\\\d\\nlast\n" \
"A: simple_attr=1\n" \
"\n");
	_g_free0 (syspath);
	_g_object_unref0 (tb);
	_g_free0 (serr);
	_g_free0 (sout);
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = needle;
	_tmp1_ = strstr ((gchar*) self, (gchar*) _tmp0_);
	result = _tmp1_ != NULL;
	return result;
}


void t_testbed_multiple (void) {
	gchar* sout = NULL;
	gchar* serr = NULL;
	gint exit = 0;
	UMockdevTestbed* _tmp0_;
	UMockdevTestbed* tb;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	gchar** _tmp4_;
	gint _tmp4__length1;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar** _tmp7_ = NULL;
	gchar** _tmp8_;
	gint _tmp8__length1;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_;
	gchar* dev1;
	gchar* _tmp11_;
	gchar* _tmp12_;
	gchar** _tmp13_ = NULL;
	gchar** _tmp14_;
	gint _tmp14__length1;
	gchar* _tmp15_;
	gchar* _tmp16_;
	gchar** _tmp17_ = NULL;
	gchar** _tmp18_;
	gint _tmp18__length1;
	gchar* _tmp19_ = NULL;
	gchar* _tmp20_;
	gchar* subdev1;
	gchar* _tmp21_;
	gchar* _tmp22_;
	gchar** _tmp23_ = NULL;
	gchar** _tmp24_;
	gint _tmp24__length1;
	gchar* _tmp25_;
	gchar* _tmp26_;
	gchar** _tmp27_ = NULL;
	gchar** _tmp28_;
	gint _tmp28__length1;
	gchar* _tmp29_ = NULL;
	gchar* _tmp30_;
	const gchar* _tmp31_;
	gchar* _tmp32_;
	gchar* _tmp33_;
	gchar* _tmp34_;
	gchar* _tmp35_;
	gchar* _tmp36_ = NULL;
	gchar* _tmp37_ = NULL;
	gint _tmp38_ = 0;
	const gchar* _tmp39_;
	gint _tmp40_;
	const gchar* _tmp41_;
	const gchar* _tmp42_;
	gchar* _tmp43_;
	gchar* _tmp44_;
	gchar* _tmp45_;
	gchar* _tmp46_;
	gchar* _tmp47_ = NULL;
	gchar* _tmp48_ = NULL;
	gint _tmp49_ = 0;
	const gchar* _tmp50_;
	gint _tmp51_;
	const gchar* _tmp52_;
	const gchar* _tmp53_;
	gchar* _tmp54_;
	gchar* _tmp55_;
	gchar* _tmp56_ = NULL;
	gchar* _tmp57_ = NULL;
	gint _tmp58_ = 0;
	const gchar* _tmp59_;
	gint _tmp60_;
	const gchar* _tmp61_;
	gboolean _tmp62_ = FALSE;
	const gchar* _tmp63_;
	gboolean _tmp64_ = FALSE;
	const gchar* _tmp65_;
	gboolean _tmp66_ = FALSE;
	_tmp0_ = umockdev_testbed_new ();
	tb = _tmp0_;
	_tmp1_ = g_strdup ("dev1color");
	_tmp2_ = g_strdup ("green");
	_tmp3_ = g_new0 (gchar*, 2 + 1);
	_tmp3_[0] = _tmp1_;
	_tmp3_[1] = _tmp2_;
	_tmp4_ = _tmp3_;
	_tmp4__length1 = 2;
	_tmp5_ = g_strdup ("DEV1COLOR");
	_tmp6_ = g_strdup ("GREEN");
	_tmp7_ = g_new0 (gchar*, 2 + 1);
	_tmp7_[0] = _tmp5_;
	_tmp7_[1] = _tmp6_;
	_tmp8_ = _tmp7_;
	_tmp8__length1 = 2;
	_tmp9_ = umockdev_testbed_add_devicev (tb, "pci", "dev1", NULL, _tmp4_, _tmp8_);
	_tmp10_ = _tmp9_;
	_tmp8_ = (_vala_array_free (_tmp8_, _tmp8__length1, (GDestroyNotify) g_free), NULL);
	_tmp4_ = (_vala_array_free (_tmp4_, _tmp4__length1, (GDestroyNotify) g_free), NULL);
	dev1 = _tmp10_;
	_tmp11_ = g_strdup ("subdev1color");
	_tmp12_ = g_strdup ("yellow");
	_tmp13_ = g_new0 (gchar*, 2 + 1);
	_tmp13_[0] = _tmp11_;
	_tmp13_[1] = _tmp12_;
	_tmp14_ = _tmp13_;
	_tmp14__length1 = 2;
	_tmp15_ = g_strdup ("SUBDEV1COLOR");
	_tmp16_ = g_strdup ("YELLOW");
	_tmp17_ = g_new0 (gchar*, 2 + 1);
	_tmp17_[0] = _tmp15_;
	_tmp17_[1] = _tmp16_;
	_tmp18_ = _tmp17_;
	_tmp18__length1 = 2;
	_tmp19_ = umockdev_testbed_add_devicev (tb, "pci", "subdev1", dev1, _tmp14_, _tmp18_);
	_tmp20_ = _tmp19_;
	_tmp18_ = (_vala_array_free (_tmp18_, _tmp18__length1, (GDestroyNotify) g_free), NULL);
	_tmp14_ = (_vala_array_free (_tmp14_, _tmp14__length1, (GDestroyNotify) g_free), NULL);
	subdev1 = _tmp20_;
	_tmp21_ = g_strdup ("dev2color");
	_tmp22_ = g_strdup ("brown");
	_tmp23_ = g_new0 (gchar*, 2 + 1);
	_tmp23_[0] = _tmp21_;
	_tmp23_[1] = _tmp22_;
	_tmp24_ = _tmp23_;
	_tmp24__length1 = 2;
	_tmp25_ = g_strdup ("DEV2COLOR");
	_tmp26_ = g_strdup ("BROWN");
	_tmp27_ = g_new0 (gchar*, 2 + 1);
	_tmp27_[0] = _tmp25_;
	_tmp27_[1] = _tmp26_;
	_tmp28_ = _tmp27_;
	_tmp28__length1 = 2;
	_tmp29_ = umockdev_testbed_add_devicev (tb, "pci", "dev2", NULL, _tmp24_, _tmp28_);
	_tmp30_ = _tmp29_;
	_g_free0 (_tmp30_);
	_tmp28_ = (_vala_array_free (_tmp28_, _tmp28__length1, (GDestroyNotify) g_free), NULL);
	_tmp24_ = (_vala_array_free (_tmp24_, _tmp24__length1, (GDestroyNotify) g_free), NULL);
	_tmp31_ = umockdev_record_path;
	_tmp32_ = g_strconcat (_tmp31_, " ", NULL);
	_tmp33_ = _tmp32_;
	_tmp34_ = g_strconcat (_tmp33_, subdev1, NULL);
	_tmp35_ = _tmp34_;
	spawn (_tmp35_, &_tmp36_, &_tmp37_, &_tmp38_);
	_g_free0 (sout);
	sout = _tmp36_;
	_g_free0 (serr);
	serr = _tmp37_;
	exit = _tmp38_;
	_g_free0 (_tmp35_);
	_g_free0 (_tmp33_);
	_tmp39_ = serr;
	g_assert_cmpstr (_tmp39_, ==, "");
	_tmp40_ = exit;
	g_assert_cmpint (_tmp40_, ==, 0);
	_tmp41_ = sout;
	g_assert_cmpstr (_tmp41_, ==, "P: /devices/dev1/subdev1\n" \
"E: SUBDEV1COLOR=YELLOW\n" \
"E: SUBSYSTEM=pci\n" \
"A: subdev1color=yellow\n" \
"\n" \
"P: /devices/dev1\n" \
"E: DEV1COLOR=GREEN\n" \
"E: SUBSYSTEM=pci\n" \
"A: dev1color=green\n" \
"\n");
	_tmp42_ = umockdev_record_path;
	_tmp43_ = g_strconcat (_tmp42_, " ", NULL);
	_tmp44_ = _tmp43_;
	_tmp45_ = g_strconcat (_tmp44_, dev1, NULL);
	_tmp46_ = _tmp45_;
	spawn (_tmp46_, &_tmp47_, &_tmp48_, &_tmp49_);
	_g_free0 (sout);
	sout = _tmp47_;
	_g_free0 (serr);
	serr = _tmp48_;
	exit = _tmp49_;
	_g_free0 (_tmp46_);
	_g_free0 (_tmp44_);
	_tmp50_ = serr;
	g_assert_cmpstr (_tmp50_, ==, "");
	_tmp51_ = exit;
	g_assert_cmpint (_tmp51_, ==, 0);
	_tmp52_ = sout;
	g_assert_cmpstr (_tmp52_, ==, "P: /devices/dev1\n" \
"E: DEV1COLOR=GREEN\n" \
"E: SUBSYSTEM=pci\n" \
"A: dev1color=green\n" \
"\n");
	_tmp53_ = umockdev_record_path;
	_tmp54_ = g_strconcat (_tmp53_, " --all", NULL);
	_tmp55_ = _tmp54_;
	spawn (_tmp55_, &_tmp56_, &_tmp57_, &_tmp58_);
	_g_free0 (sout);
	sout = _tmp56_;
	_g_free0 (serr);
	serr = _tmp57_;
	exit = _tmp58_;
	_g_free0 (_tmp55_);
	_tmp59_ = serr;
	g_assert_cmpstr (_tmp59_, ==, "");
	_tmp60_ = exit;
	g_assert_cmpint (_tmp60_, ==, 0);
	_tmp61_ = sout;
	_tmp62_ = string_contains (_tmp61_, "P: /devices/dev1/subdev1\n");
	_vala_assert (_tmp62_, "sout.contains (\"P: /devices/dev1/subdev1\\n\")");
	_tmp63_ = sout;
	_tmp64_ = string_contains (_tmp63_, "P: /devices/dev1\n");
	_vala_assert (_tmp64_, "sout.contains (\"P: /devices/dev1\\n\")");
	_tmp65_ = sout;
	_tmp66_ = string_contains (_tmp65_, "P: /devices/dev2\n");
	_vala_assert (_tmp66_, "sout.contains (\"P: /devices/dev2\\n\")");
	_g_free0 (subdev1);
	_g_free0 (dev1);
	_g_object_unref0 (tb);
	_g_free0 (serr);
	_g_free0 (sout);
}


void t_testbed_no_ioctl_record (void) {
	gchar* sout = NULL;
	gchar* serr = NULL;
	gint exit = 0;
	UMockdevTestbed* _tmp0_;
	UMockdevTestbed* tb;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	gchar** _tmp4_;
	gint _tmp4__length1;
	gchar** _tmp5_ = NULL;
	gchar** _tmp6_;
	gint _tmp6__length1;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	const gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	gint _tmp14_ = 0;
	gboolean _tmp15_ = FALSE;
	_tmp0_ = umockdev_testbed_new ();
	tb = _tmp0_;
	_tmp1_ = g_strdup ("dev");
	_tmp2_ = g_strdup ("1:5");
	_tmp3_ = g_new0 (gchar*, 2 + 1);
	_tmp3_[0] = _tmp1_;
	_tmp3_[1] = _tmp2_;
	_tmp4_ = _tmp3_;
	_tmp4__length1 = 2;
	_tmp5_ = g_new0 (gchar*, 0 + 1);
	_tmp6_ = _tmp5_;
	_tmp6__length1 = 0;
	_tmp7_ = umockdev_testbed_add_devicev (tb, "mem", "zero", NULL, _tmp4_, _tmp6_);
	_tmp8_ = _tmp7_;
	_g_free0 (_tmp8_);
	_tmp6_ = (_vala_array_free (_tmp6_, _tmp6__length1, (GDestroyNotify) g_free), NULL);
	_tmp4_ = (_vala_array_free (_tmp4_, _tmp4__length1, (GDestroyNotify) g_free), NULL);
	_tmp9_ = umockdev_record_path;
	_tmp10_ = g_strconcat (_tmp9_, " --ioctl /sys/devices/zero=/dev/stdout -- head -c1 /dev/zero", NULL);
	_tmp11_ = _tmp10_;
	spawn (_tmp11_, &_tmp12_, &_tmp13_, &_tmp14_);
	_g_free0 (sout);
	sout = _tmp12_;
	_g_free0 (serr);
	serr = _tmp13_;
	exit = _tmp14_;
	_g_free0 (_tmp11_);
	g_assert_cmpint (exit, !=, 0);
	g_assert_cmpstr (sout, ==, "");
	_tmp15_ = string_contains (serr, "UMOCKDEV_DIR cannot be used");
	_vala_assert (_tmp15_, "serr.contains (\"UMOCKDEV_DIR cannot be used\")");
	_g_object_unref0 (tb);
	_g_free0 (serr);
	_g_free0 (sout);
}


void t_system_all (void) {
	gchar* sout = NULL;
	gchar* serr = NULL;
	gint exit = 0;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	gboolean _tmp6_ = FALSE;
	gint _tmp7_;
	gint _tmp8_;
	UMockdevTestbed* _tmp9_;
	UMockdevTestbed* tb;
	GError * _inner_error_ = NULL;
	_tmp0_ = umockdev_record_path;
	_tmp1_ = g_strconcat (_tmp0_, " --all", NULL);
	_tmp2_ = _tmp1_;
	spawn (_tmp2_, &_tmp3_, &_tmp4_, &_tmp5_);
	_g_free0 (sout);
	sout = _tmp3_;
	_g_free0 (serr);
	serr = _tmp4_;
	exit = _tmp5_;
	_g_free0 (_tmp2_);
	g_assert_cmpstr (serr, ==, "");
	g_assert_cmpint (exit, ==, 0);
	_tmp6_ = g_str_has_prefix (sout, "P:");
	_vala_assert (_tmp6_, "sout.has_prefix (\"P:\")");
	_tmp7_ = strlen (sout);
	_tmp8_ = _tmp7_;
	g_assert_cmpint (_tmp8_, >=, 100);
	_tmp9_ = umockdev_testbed_new ();
	tb = _tmp9_;
	{
		gboolean _tmp10_ = FALSE;
		gboolean _tmp11_;
		_tmp10_ = umockdev_testbed_add_from_string (tb, sout, &_inner_error_);
		_tmp11_ = _tmp10_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == UMOCKDEV_ERROR) {
				goto __catch2_umockdev_error;
			}
			_g_object_unref0 (tb);
			_g_free0 (serr);
			_g_free0 (sout);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_vala_assert (_tmp11_, "tb.add_from_string (sout)");
	}
	goto __finally2;
	__catch2_umockdev_error:
	{
		GError* e = NULL;
		FILE* _tmp12_;
		const gchar* _tmp13_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp12_ = stderr;
		_tmp13_ = e->message;
		fprintf (_tmp12_, "Error when adding system dump to testbed: %s\n", _tmp13_);
		abort ();
		_g_error_free0 (e);
	}
	__finally2:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (tb);
		_g_free0 (serr);
		_g_free0 (sout);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (tb);
	_g_free0 (serr);
	_g_free0 (sout);
}


void t_system_ioctl_log (void) {
	gchar* sout = NULL;
	gchar* serr = NULL;
	gint exit = 0;
	gchar* workdir = NULL;
	gchar* _tmp2_ = NULL;
	gchar* log;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	gint _tmp12_ = 0;
	const gchar* _tmp13_;
	gint _tmp14_;
	const gchar* _tmp15_;
	gboolean _tmp16_ = FALSE;
	const gchar* _tmp17_;
	gchar* _tmp18_;
	gchar* _tmp19_;
	gchar* _tmp20_;
	gchar* _tmp21_;
	gchar* _tmp22_;
	gchar* _tmp23_;
	gchar* _tmp24_ = NULL;
	gchar* _tmp25_ = NULL;
	gint _tmp26_ = 0;
	const gchar* _tmp27_;
	gint _tmp28_;
	const gchar* _tmp29_;
	gboolean _tmp30_ = FALSE;
	gchar* _tmp31_ = NULL;
	gchar* _tmp32_;
	const gchar* _tmp33_;
	gchar* _tmp34_;
	gchar* _tmp35_;
	gchar* _tmp36_ = NULL;
	gchar* _tmp37_ = NULL;
	gint _tmp38_ = 0;
	gint _tmp39_;
	const gchar* _tmp40_;
	const gchar* _tmp41_;
	gboolean _tmp42_ = FALSE;
	const gchar* _tmp43_;
	gboolean _tmp44_ = FALSE;
	gboolean _tmp45_ = FALSE;
	GError * _inner_error_ = NULL;
	{
		gchar* _tmp0_ = NULL;
		gchar* _tmp1_;
		_tmp0_ = g_dir_make_tmp ("ioctl_log_test.XXXXXX", &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			goto __catch3_g_error;
		}
		_g_free0 (workdir);
		workdir = _tmp1_;
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		abort ();
		_g_error_free0 (e);
	}
	__finally3:
	if (_inner_error_ != NULL) {
		_g_free0 (workdir);
		_g_free0 (serr);
		_g_free0 (sout);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp2_ = g_build_filename (workdir, "log", NULL);
	log = _tmp2_;
	_tmp3_ = umockdev_record_path;
	_tmp4_ = g_strconcat (_tmp3_, " --ioctl=/dev/null=", NULL);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_strconcat (_tmp5_, log, NULL);
	_tmp7_ = _tmp6_;
	_tmp8_ = g_strconcat (_tmp7_, " -- head -c1 /dev/zero", NULL);
	_tmp9_ = _tmp8_;
	spawn (_tmp9_, &_tmp10_, &_tmp11_, &_tmp12_);
	_g_free0 (sout);
	sout = _tmp10_;
	_g_free0 (serr);
	serr = _tmp11_;
	exit = _tmp12_;
	_g_free0 (_tmp9_);
	_g_free0 (_tmp7_);
	_g_free0 (_tmp5_);
	_tmp13_ = serr;
	g_assert_cmpstr (_tmp13_, ==, "");
	_tmp14_ = exit;
	g_assert_cmpint (_tmp14_, ==, 0);
	_tmp15_ = sout;
	g_assert_cmpstr (_tmp15_, ==, "\0");
	_tmp16_ = g_file_test (log, G_FILE_TEST_EXISTS);
	_vala_assert (!_tmp16_, "!FileUtils.test (log, FileTest.EXISTS)");
	_tmp17_ = umockdev_record_path;
	_tmp18_ = g_strconcat (_tmp17_, " --ioctl /dev/zero=", NULL);
	_tmp19_ = _tmp18_;
	_tmp20_ = g_strconcat (_tmp19_, log, NULL);
	_tmp21_ = _tmp20_;
	_tmp22_ = g_strconcat (_tmp21_, " -- head -c1 /dev/zero", NULL);
	_tmp23_ = _tmp22_;
	spawn (_tmp23_, &_tmp24_, &_tmp25_, &_tmp26_);
	_g_free0 (sout);
	sout = _tmp24_;
	_g_free0 (serr);
	serr = _tmp25_;
	exit = _tmp26_;
	_g_free0 (_tmp23_);
	_g_free0 (_tmp21_);
	_g_free0 (_tmp19_);
	_tmp27_ = serr;
	g_assert_cmpstr (_tmp27_, ==, "");
	_tmp28_ = exit;
	g_assert_cmpint (_tmp28_, ==, 0);
	_tmp29_ = sout;
	g_assert_cmpstr (_tmp29_, ==, "\0");
	_tmp30_ = g_file_test (log, G_FILE_TEST_EXISTS);
	_vala_assert (_tmp30_, "FileUtils.test (log, FileTest.EXISTS)");
	_tmp31_ = file_contents (log);
	_tmp32_ = _tmp31_;
	g_assert_cmpstr (_tmp32_, ==, "");
	_g_free0 (_tmp32_);
	g_remove (log);
	_tmp33_ = umockdev_record_path;
	_tmp34_ = g_strconcat (_tmp33_, " --ioctl /dev/null -- head -c1 /dev/zero", NULL);
	_tmp35_ = _tmp34_;
	spawn (_tmp35_, &_tmp36_, &_tmp37_, &_tmp38_);
	_g_free0 (sout);
	sout = _tmp36_;
	_g_free0 (serr);
	serr = _tmp37_;
	exit = _tmp38_;
	_g_free0 (_tmp35_);
	_tmp39_ = exit;
	g_assert_cmpint (_tmp39_, !=, 1);
	_tmp40_ = sout;
	g_assert_cmpstr (_tmp40_, ==, "");
	_tmp41_ = serr;
	_tmp42_ = string_contains (_tmp41_, "--ioctl");
	_vala_assert (_tmp42_, "serr.contains (\"--ioctl\")");
	_tmp43_ = serr;
	_tmp44_ = string_contains (_tmp43_, "=");
	_vala_assert (_tmp44_, "serr.contains (\"=\")");
	_tmp45_ = g_file_test (log, G_FILE_TEST_EXISTS);
	_vala_assert (!_tmp45_, "!FileUtils.test (log, FileTest.EXISTS)");
	g_rmdir (workdir);
	_g_free0 (log);
	_g_free0 (workdir);
	_g_free0 (serr);
	_g_free0 (sout);
}


void t_system_script_log_simple (void) {
	gchar* sout = NULL;
	gchar* serr = NULL;
	gint exit = 0;
	gchar* log = NULL;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	gint _tmp12_ = 0;
	const gchar* _tmp13_;
	gint _tmp14_;
	const gchar* _tmp15_;
	gchar* _tmp16_ = NULL;
	gchar* _tmp17_;
	const gchar* _tmp18_;
	gchar* _tmp19_;
	gchar* _tmp20_;
	gchar* _tmp21_;
	gchar* _tmp22_;
	gchar* _tmp23_;
	gchar* _tmp24_;
	gchar* _tmp25_ = NULL;
	gchar* _tmp26_ = NULL;
	gint _tmp27_ = 0;
	const gchar* _tmp28_;
	gint _tmp29_;
	const gchar* _tmp30_;
	gchar* _tmp31_ = NULL;
	gchar* _tmp32_;
	gchar** _tmp33_;
	gchar** _tmp34_ = NULL;
	gchar** _tmp35_;
	gint _tmp35__length1;
	gchar** logwords;
	gint logwords_length1;
	gint _logwords_size_;
	const gchar* _tmp36_;
	const gchar* _tmp37_;
	gint _tmp38_ = 0;
	const gchar* _tmp39_;
	GError * _inner_error_ = NULL;
	{
		gchar* _tmp0_ = NULL;
		gint _tmp1_ = 0;
		gint _tmp2_;
		_tmp1_ = g_file_open_tmp ("test_script_log.XXXXXX", &_tmp0_, &_inner_error_);
		_g_free0 (log);
		log = _tmp0_;
		_tmp2_ = _tmp1_;
		if (_inner_error_ != NULL) {
			goto __catch4_g_error;
		}
		close (_tmp2_);
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		abort ();
		_g_error_free0 (e);
	}
	__finally4:
	if (_inner_error_ != NULL) {
		_g_free0 (log);
		_g_free0 (serr);
		_g_free0 (sout);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp3_ = umockdev_record_path;
	_tmp4_ = g_strconcat (_tmp3_, " --script=/dev/null=", NULL);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_strconcat (_tmp5_, log, NULL);
	_tmp7_ = _tmp6_;
	_tmp8_ = g_strconcat (_tmp7_, " -- head -c1 /dev/zero", NULL);
	_tmp9_ = _tmp8_;
	spawn (_tmp9_, &_tmp10_, &_tmp11_, &_tmp12_);
	_g_free0 (sout);
	sout = _tmp10_;
	_g_free0 (serr);
	serr = _tmp11_;
	exit = _tmp12_;
	_g_free0 (_tmp9_);
	_g_free0 (_tmp7_);
	_g_free0 (_tmp5_);
	_tmp13_ = serr;
	g_assert_cmpstr (_tmp13_, ==, "");
	_tmp14_ = exit;
	g_assert_cmpint (_tmp14_, ==, 0);
	_tmp15_ = sout;
	g_assert_cmpstr (_tmp15_, ==, "\0");
	_tmp16_ = file_contents (log);
	_tmp17_ = _tmp16_;
	g_assert_cmpstr (_tmp17_, ==, "");
	_g_free0 (_tmp17_);
	_tmp18_ = umockdev_record_path;
	_tmp19_ = g_strconcat (_tmp18_, " --script=/dev/zero=", NULL);
	_tmp20_ = _tmp19_;
	_tmp21_ = g_strconcat (_tmp20_, log, NULL);
	_tmp22_ = _tmp21_;
	_tmp23_ = g_strconcat (_tmp22_, " -- head -c1 /dev/zero", NULL);
	_tmp24_ = _tmp23_;
	spawn (_tmp24_, &_tmp25_, &_tmp26_, &_tmp27_);
	_g_free0 (sout);
	sout = _tmp25_;
	_g_free0 (serr);
	serr = _tmp26_;
	exit = _tmp27_;
	_g_free0 (_tmp24_);
	_g_free0 (_tmp22_);
	_g_free0 (_tmp20_);
	_tmp28_ = serr;
	g_assert_cmpstr (_tmp28_, ==, "");
	_tmp29_ = exit;
	g_assert_cmpint (_tmp29_, ==, 0);
	_tmp30_ = sout;
	g_assert_cmpstr (_tmp30_, ==, "\0");
	_tmp31_ = file_contents (log);
	_tmp32_ = _tmp31_;
	_tmp34_ = _tmp33_ = g_strsplit (_tmp32_, " ", 0);
	_tmp35_ = _tmp34_;
	_tmp35__length1 = _vala_array_length (_tmp33_);
	_g_free0 (_tmp32_);
	logwords = _tmp35_;
	logwords_length1 = _tmp35__length1;
	_logwords_size_ = logwords_length1;
	g_assert_cmpuint ((guint) logwords_length1, ==, (guint) 3);
	_tmp36_ = logwords[0];
	g_assert_cmpstr (_tmp36_, ==, "r");
	_tmp37_ = logwords[1];
	_tmp38_ = atoi (_tmp37_);
	g_assert_cmpint (_tmp38_, <=, 5);
	_tmp39_ = logwords[2];
	g_assert_cmpstr (_tmp39_, ==, "^@");
	g_remove (log);
	logwords = (_vala_array_free (logwords, logwords_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (log);
	_g_free0 (serr);
	_g_free0 (sout);
}


gchar* read_line_timeout (FILE* stream) {
	gchar* result = NULL;
	gchar* line;
	gchar buffer[1000] = {0};
	gint timeout;
	gint _tmp6_;
	gchar* _tmp7_;
	g_return_val_if_fail (stream != NULL, NULL);
	line = NULL;
	timeout = 50;
	while (TRUE) {
		gint _tmp0_;
		FILE* _tmp1_;
		const gchar* _tmp2_ = NULL;
		gchar* _tmp3_;
		const gchar* _tmp4_;
		gint _tmp5_;
		_tmp0_ = timeout;
		if (!(_tmp0_ > 0)) {
			break;
		}
		_tmp1_ = stream;
		_tmp2_ = fgets (buffer, 1000, _tmp1_);
		_tmp3_ = g_strdup (_tmp2_);
		_g_free0 (line);
		line = _tmp3_;
		_tmp4_ = line;
		if (_tmp4_ != NULL) {
			result = line;
			return result;
		}
		g_usleep ((gulong) 100000);
		_tmp5_ = timeout;
		timeout = _tmp5_ - 1;
	}
	_tmp6_ = timeout;
	_vala_assert (_tmp6_ > 0, "timeout > 0");
	_tmp7_ = g_strdup ("<timeout>");
	result = _tmp7_;
	_g_free0 (line);
	return result;
}


void t_system_script_log_chatter (void) {
	gchar* log = NULL;
	gchar* _tmp3_ = NULL;
	gchar* ptyname;
	gint ptyname_length1;
	gint _ptyname_size_;
	gint ptym = 0;
	gint ptys = 0;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	gint _tmp6_ = 0;
	struct termios ios = {0};
	struct termios _tmp7_ = {0};
	gint _tmp8_ = 0;
	tcflag_t _tmp9_;
	tcflag_t _tmp10_;
	tcflag_t _tmp11_;
	struct termios _tmp12_;
	gint _tmp13_ = 0;
	GPid chatter_pid = 0;
	FILE* _tmp32_ = NULL;
	FILE* chatter_stream;
	FILE* _tmp33_;
	FILE* _tmp34_;
	gchar* _tmp35_ = NULL;
	gchar* _tmp36_;
	FILE* _tmp37_;
	gchar* _tmp38_ = NULL;
	gchar* _tmp39_;
	FILE* _tmp40_;
	FILE* _tmp46_;
	FILE* _tmp47_;
	gchar* _tmp48_ = NULL;
	gchar* _tmp49_;
	gint status = 0;
	gint _tmp50_ = 0;
	pid_t _tmp51_ = 0;
	FILE* _tmp52_ = NULL;
	FILE* log_stream;
	gint time;
	gint _tmp53_ = 0;
	gint _tmp54_ = 0;
	gint _tmp55_ = 0;
	gint _tmp56_ = 0;
	GError * _inner_error_ = NULL;
	{
		gchar* _tmp0_ = NULL;
		gint _tmp1_ = 0;
		gint _tmp2_;
		_tmp1_ = g_file_open_tmp ("test_script_log.XXXXXX", &_tmp0_, &_inner_error_);
		_g_free0 (log);
		log = _tmp0_;
		_tmp2_ = _tmp1_;
		if (_inner_error_ != NULL) {
			goto __catch5_g_error;
		}
		close (_tmp2_);
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		abort ();
		_g_error_free0 (e);
	}
	__finally5:
	if (_inner_error_ != NULL) {
		_g_free0 (log);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp3_ = g_new0 (gchar, 8192);
	ptyname = _tmp3_;
	ptyname_length1 = 8192;
	_ptyname_size_ = ptyname_length1;
	_tmp6_ = openpty (&_tmp4_, &_tmp5_, ptyname, NULL, NULL);
	ptym = _tmp4_;
	ptys = _tmp5_;
	_vala_assert (_tmp6_ == 0, "Linux.openpty (out ptym, out ptys, ptyname, null, null) == 0");
	close (ptys);
	_tmp8_ = tcgetattr (ptym, &_tmp7_);
	ios = _tmp7_;
	_vala_assert (_tmp8_ == 0, "Posix.tcgetattr (ptym, out ios) == 0");
	_tmp9_ = ios.c_iflag;
	ios.c_iflag = _tmp9_ & (~((IGNCR | INLCR) | ICRNL));
	_tmp10_ = ios.c_oflag;
	ios.c_oflag = _tmp10_ & (~(ONLCR | OCRNL));
	_tmp11_ = ios.c_lflag;
	ios.c_lflag = _tmp11_ & (~(ICANON | ECHO));
	_tmp12_ = ios;
	_tmp13_ = tcsetattr (ptym, TCSANOW, &_tmp12_);
	_vala_assert (_tmp13_ == 0, "Posix.tcsetattr (ptym, Posix.TCSANOW, ios) == 0");
	{
		const gchar* _tmp14_;
		gchar* _tmp15_;
		gchar* _tmp16_;
		gchar* _tmp17_;
		gchar* _tmp18_;
		gchar* _tmp19_;
		gchar* _tmp20_;
		const gchar* _tmp21_;
		gchar* _tmp22_ = NULL;
		gchar* _tmp23_;
		gchar** _tmp24_ = NULL;
		gchar** _tmp25_;
		gint _tmp25__length1;
		GPid _tmp26_ = 0;
		gboolean _tmp27_ = FALSE;
		gboolean _tmp28_;
		gboolean _tmp29_;
		_tmp14_ = umockdev_record_path;
		_tmp15_ = g_strdup (_tmp14_);
		_tmp16_ = g_strdup ("--script");
		_tmp17_ = g_strconcat ((const gchar*) ptyname, "=", NULL);
		_tmp18_ = _tmp17_;
		_tmp19_ = g_strconcat (_tmp18_, log, NULL);
		_tmp20_ = g_strdup ("--");
		_tmp21_ = rootdir;
		_tmp22_ = g_build_filename (_tmp21_, "tests", "chatter", NULL);
		_tmp23_ = g_strdup ((const gchar*) ptyname);
		_tmp24_ = g_new0 (gchar*, 6 + 1);
		_tmp24_[0] = _tmp15_;
		_tmp24_[1] = _tmp16_;
		_tmp24_[2] = _tmp19_;
		_tmp24_[3] = _tmp20_;
		_tmp24_[4] = _tmp22_;
		_tmp24_[5] = _tmp23_;
		_tmp25_ = _tmp24_;
		_tmp25__length1 = 6;
		_tmp27_ = g_spawn_async_with_pipes (NULL, _tmp25_, NULL, (G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD) | G_SPAWN_STDOUT_TO_DEV_NULL, NULL, NULL, &_tmp26_, NULL, NULL, NULL, &_inner_error_);
		chatter_pid = _tmp26_;
		_tmp28_ = _tmp27_;
		_tmp25_ = (_vala_array_free (_tmp25_, _tmp25__length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (_tmp18_);
		_tmp29_ = _tmp28_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_SPAWN_ERROR) {
				goto __catch6_g_spawn_error;
			}
			ptyname = (g_free (ptyname), NULL);
			_g_free0 (log);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_vala_assert (_tmp29_, "Process.spawn_async_with_pipes (null,             {umockdev_record_path, \"--script\", (string) ptyname + \"=\" + log, \"--\",              Path.build_filename (rootdir, \"tests\", \"chatter\"), (string) ptyname},             null, SpawnFlags.SEARCH_PATH | SpawnFlags.DO_NOT_REAP_CHILD | SpawnFlags.STDOUT_TO_DEV_NULL,             null, out chatter_pid, null, null, null)");
	}
	goto __finally6;
	__catch6_g_spawn_error:
	{
		GError* e = NULL;
		FILE* _tmp30_;
		const gchar* _tmp31_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp30_ = stderr;
		_tmp31_ = e->message;
		fprintf (_tmp30_, "Cannot call umockdev-record: %s\n", _tmp31_);
		abort ();
		_g_error_free0 (e);
	}
	__finally6:
	if (_inner_error_ != NULL) {
		ptyname = (g_free (ptyname), NULL);
		_g_free0 (log);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp32_ = fdopen (ptym, "r+");
	chatter_stream = _tmp32_;
	_tmp33_ = chatter_stream;
	_vala_assert (_tmp33_ != NULL, "chatter_stream != null");
	_tmp34_ = chatter_stream;
	_tmp35_ = read_line_timeout (_tmp34_);
	_tmp36_ = _tmp35_;
	g_assert_cmpstr (_tmp36_, ==, "Hello world!\n");
	_g_free0 (_tmp36_);
	_tmp37_ = chatter_stream;
	_tmp38_ = read_line_timeout (_tmp37_);
	_tmp39_ = _tmp38_;
	g_assert_cmpstr (_tmp39_, ==, "What is your name?\n");
	_g_free0 (_tmp39_);
	g_usleep ((gulong) 500000);
	_tmp40_ = chatter_stream;
	fputs ("John\n", _tmp40_);
	while (TRUE) {
		FILE* _tmp41_;
		gchar* _tmp42_ = NULL;
		gchar* _tmp43_;
		gboolean _tmp44_ = FALSE;
		gboolean _tmp45_;
		_tmp41_ = chatter_stream;
		_tmp42_ = read_line_timeout (_tmp41_);
		_tmp43_ = _tmp42_;
		_tmp44_ = string_contains (_tmp43_, "line break in one write");
		_tmp45_ = !(!_tmp44_);
		_g_free0 (_tmp43_);
		if (_tmp45_) {
			break;
		}
	}
	g_usleep ((gulong) 300000);
	_tmp46_ = chatter_stream;
	fputs ("foo ☹ bar !\n", _tmp46_);
	_tmp47_ = chatter_stream;
	_tmp48_ = read_line_timeout (_tmp47_);
	_tmp49_ = _tmp48_;
	g_assert_cmpstr (_tmp49_, ==, "bye!\n");
	_g_free0 (_tmp49_);
	_tmp51_ = waitpid ((pid_t) chatter_pid, &_tmp50_, 0);
	status = _tmp50_;
	g_assert_cmpint ((gint) _tmp51_, ==, (gint) chatter_pid);
	g_assert_cmpint (status, ==, 0);
	_tmp52_ = g_fopen (log, "r");
	log_stream = _tmp52_;
	time = 0;
	_tmp53_ = fscanf (log_stream, "w %d Hello world!^JWhat is your name?^J\n", &time);
	g_assert_cmpint (_tmp53_, ==, 1);
	g_assert_cmpint (time, <=, 20);
	_tmp54_ = fscanf (log_stream, "r %d John^J\n", &time);
	g_assert_cmpint (_tmp54_, ==, 1);
	g_assert_cmpint (time, >=, 450);
	g_assert_cmpint (time, <=, 800);
	_tmp55_ = fscanf (log_stream, "w %d I ♥ John^Ja^I tab and a^J line break in one write^J\n", &time);
	g_assert_cmpint (_tmp55_, ==, 1);
	g_assert_cmpint (time, <=, 20);
	_tmp56_ = fscanf (log_stream, "r %d foo ☹ bar!^J\n", &time);
	g_assert_cmpint (_tmp56_, ==, 1);
	g_assert_cmpint (time, >=, 250);
	g_assert_cmpint (time, <=, 450);
	g_remove (log);
	_fclose0 (log_stream);
	_fclose0 (chatter_stream);
	ptyname = (g_free (ptyname), NULL);
	_g_free0 (log);
}


static void _t_testbed_all_empty_gtest_func (void) {
	t_testbed_all_empty ();
}


static void _t_testbed_one_gtest_func (void) {
	t_testbed_one ();
}


static void _t_testbed_multiple_gtest_func (void) {
	t_testbed_multiple ();
}


static void _t_testbed_no_ioctl_record_gtest_func (void) {
	t_testbed_no_ioctl_record ();
}


static void _t_system_all_gtest_func (void) {
	t_system_all ();
}


static void _t_system_ioctl_log_gtest_func (void) {
	t_system_ioctl_log ();
}


static void _t_system_script_log_simple_gtest_func (void) {
	t_system_script_log_simple ();
}


static void _t_system_script_log_chatter_gtest_func (void) {
	t_system_script_log_chatter ();
}


gint _vala_main (gchar** args, int args_length1) {
	gint result = 0;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* r;
	const gchar* _tmp2_;
	const gchar* _tmp14_;
	gchar* _tmp15_ = NULL;
	gint _tmp16_ = 0;
	g_test_init (&args_length1, &args, NULL);
	_tmp0_ = g_getenv ("TOP_BUILDDIR");
	_tmp1_ = g_strdup (_tmp0_);
	r = _tmp1_;
	_tmp2_ = r;
	if (_tmp2_ == NULL) {
		gchar** _tmp3_;
		gint _tmp3__length1;
		const gchar* _tmp4_;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		gchar* _tmp11_ = NULL;
		_tmp3_ = args;
		_tmp3__length1 = args_length1;
		_tmp4_ = _tmp3_[0];
		_tmp5_ = realpath (_tmp4_, NULL);
		_tmp6_ = _tmp5_;
		_tmp7_ = g_path_get_dirname (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = g_path_get_dirname (_tmp8_);
		_tmp10_ = _tmp9_;
		_tmp11_ = g_path_get_dirname (_tmp10_);
		_g_free0 (rootdir);
		rootdir = _tmp11_;
		_g_free0 (_tmp10_);
		_g_free0 (_tmp8_);
		_g_free0 (_tmp6_);
	} else {
		const gchar* _tmp12_;
		gchar* _tmp13_;
		_tmp12_ = r;
		_tmp13_ = g_strdup (_tmp12_);
		_g_free0 (rootdir);
		rootdir = _tmp13_;
	}
	_tmp14_ = rootdir;
	_tmp15_ = g_build_filename (_tmp14_, "src", "umockdev-record", NULL);
	_g_free0 (umockdev_record_path);
	umockdev_record_path = _tmp15_;
	g_test_add_func ("/umockdev-record/testbed-all-empty", _t_testbed_all_empty_gtest_func);
	g_test_add_func ("/umockdev-record/testbed-one", _t_testbed_one_gtest_func);
	g_test_add_func ("/umockdev-record/testbed-multiple", _t_testbed_multiple_gtest_func);
	g_test_add_func ("/umockdev-record/testbed-no-ioctl-record", _t_testbed_no_ioctl_record_gtest_func);
	g_test_add_func ("/umockdev-record/system-all", _t_system_all_gtest_func);
	g_test_add_func ("/umockdev-record/ioctl-log", _t_system_ioctl_log_gtest_func);
	g_test_add_func ("/umockdev-record/script-log-simple", _t_system_script_log_simple_gtest_func);
	g_test_add_func ("/umockdev-record/script-log-chatter", _t_system_script_log_chatter_gtest_func);
	_tmp16_ = g_test_run ();
	result = _tmp16_;
	_g_free0 (r);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return _vala_main (argv, argc);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



