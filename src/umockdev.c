/* umockdev.c generated by valac 0.20.1, the Vala compiler
 * generated from umockdev.vala, do not modify */

/*
 * Copyright (C) 2012-2013 Canonical Ltd.
 * Author: Martin Pitt <martin.pitt@ubuntu.com>
 *
 * umockdev is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * umockdev is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * SECTION:umockdev
 * @title: umockdev
 * @short_description: Build a test bed for testing software that handles Linux
 * hardware devices.
 *
 * Please see README.rst about an overview of the parts of umockdev, and how
 * they fit together.
 */
/**
 * SECTION:umockdeverror
 * @title: umockdev errors
 * @short_description: #GError types for parsing umockdev files
 * hardware devices.
 *
 * See #GError for more information on error domains.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include "uevent_sender.h"
#include <unistd.h>
#include <glib/gstdio.h>
#include <stdio.h>
#include <errno.h>
#include <gio/gio.h>
#include <stdarg.h>
#include <pty.h>
#include <termios.h>
#include <sys/select.h>
#include <time.h>
#include <sys/time.h>
#include <gobject/gvaluecollector.h>


#define UMOCKDEV_TYPE_TESTBED (umockdev_testbed_get_type ())
#define UMOCKDEV_TESTBED(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UMOCKDEV_TYPE_TESTBED, UMockdevTestbed))
#define UMOCKDEV_TESTBED_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UMOCKDEV_TYPE_TESTBED, UMockdevTestbedClass))
#define UMOCKDEV_IS_TESTBED(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UMOCKDEV_TYPE_TESTBED))
#define UMOCKDEV_IS_TESTBED_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UMOCKDEV_TYPE_TESTBED))
#define UMOCKDEV_TESTBED_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UMOCKDEV_TYPE_TESTBED, UMockdevTestbedClass))

typedef struct _UMockdevTestbed UMockdevTestbed;
typedef struct _UMockdevTestbedClass UMockdevTestbedClass;
typedef struct _UMockdevTestbedPrivate UMockdevTestbedPrivate;

#define UMOCKDEV_TYPE_SCRIPT_RUNNER (umockdev_script_runner_get_type ())
#define UMOCKDEV_SCRIPT_RUNNER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UMOCKDEV_TYPE_SCRIPT_RUNNER, UMockdevScriptRunner))
#define UMOCKDEV_SCRIPT_RUNNER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UMOCKDEV_TYPE_SCRIPT_RUNNER, UMockdevScriptRunnerClass))
#define UMOCKDEV_IS_SCRIPT_RUNNER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UMOCKDEV_TYPE_SCRIPT_RUNNER))
#define UMOCKDEV_IS_SCRIPT_RUNNER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UMOCKDEV_TYPE_SCRIPT_RUNNER))
#define UMOCKDEV_SCRIPT_RUNNER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UMOCKDEV_TYPE_SCRIPT_RUNNER, UMockdevScriptRunnerClass))

typedef struct _UMockdevScriptRunner UMockdevScriptRunner;
typedef struct _UMockdevScriptRunnerClass UMockdevScriptRunnerClass;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _uevent_sender_close0(var) ((var == NULL) ? NULL : (var = (uevent_sender_close (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_match_info_free0(var) ((var == NULL) ? NULL : (var = (g_match_info_free (var), NULL)))
#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))
#define _g_dir_close0(var) ((var == NULL) ? NULL : (var = (g_dir_close (var), NULL)))
typedef struct _UMockdevScriptRunnerPrivate UMockdevScriptRunnerPrivate;
#define _g_thread_unref0(var) ((var == NULL) ? NULL : (var = (g_thread_unref (var), NULL)))
#define _umockdev_script_runner_unref0(var) ((var == NULL) ? NULL : (var = (umockdev_script_runner_unref (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
typedef struct _UMockdevParamSpecScriptRunner UMockdevParamSpecScriptRunner;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _UMockdevTestbed {
	GObject parent_instance;
	UMockdevTestbedPrivate * priv;
};

struct _UMockdevTestbedClass {
	GObjectClass parent_class;
};

struct _UMockdevTestbedPrivate {
	gchar* root_dir;
	gchar* sys_dir;
	GRegex* re_record_val;
	GRegex* re_record_keyval;
	GRegex* re_record_optval;
	uevent_sender* ev_sender;
	GHashTable* dev_fd;
	GHashTable* dev_script_runner;
};

typedef enum  {
	UMOCKDEV_ERROR_PARSE,
	UMOCKDEV_ERROR_VALUE
} UMockdevError;
#define UMOCKDEV_ERROR umockdev_error_quark ()
struct _UMockdevScriptRunner {
	GTypeInstance parent_instance;
	volatile int ref_count;
	UMockdevScriptRunnerPrivate * priv;
};

struct _UMockdevScriptRunnerClass {
	GTypeClass parent_class;
	void (*finalize) (UMockdevScriptRunner *self);
};

struct _UMockdevScriptRunnerPrivate {
	gchar* _device;
	gchar* script_file;
	GThread* thread;
	FILE* script;
	gint fd;
	gboolean running;
};

struct _UMockdevParamSpecScriptRunner {
	GParamSpec parent_instance;
};

/**
 * UMockdevError:
 * @UMOCKDEV_ERROR_PARSE:
 * There is a malformed or missing line in the device description.
 * @UMOCKDEV_ERROR_VALUE:
 * A value in the device description has an invalid value, for example a device
 * path does not start with "/devices/".
 *
 * Error codes for parsing umockdev files.
 */

static gpointer umockdev_testbed_parent_class = NULL;
static gpointer umockdev_script_runner_parent_class = NULL;

GType umockdev_testbed_get_type (void) G_GNUC_CONST;
gpointer umockdev_script_runner_ref (gpointer instance);
void umockdev_script_runner_unref (gpointer instance);
GParamSpec* umockdev_param_spec_script_runner (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void umockdev_value_set_script_runner (GValue* value, gpointer v_object);
void umockdev_value_take_script_runner (GValue* value, gpointer v_object);
gpointer umockdev_value_get_script_runner (const GValue* value);
GType umockdev_script_runner_get_type (void) G_GNUC_CONST;
#define UMOCKDEV_TESTBED_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UMOCKDEV_TYPE_TESTBED, UMockdevTestbedPrivate))
enum  {
	UMOCKDEV_TESTBED_DUMMY_PROPERTY
};
void umockdev_script_runner_stop (UMockdevScriptRunner* self);
void umockdev_remove_dir (const gchar* path, gboolean remove_toplevel);
UMockdevTestbed* umockdev_testbed_new (void);
UMockdevTestbed* umockdev_testbed_construct (GType object_type);
static void _g_free0_ (gpointer var);
static void _umockdev_script_runner_unref0_ (gpointer var);
gchar* umockdev_testbed_get_root_dir (UMockdevTestbed* self);
gchar* umockdev_testbed_get_sys_dir (UMockdevTestbed* self);
void umockdev_testbed_set_attribute (UMockdevTestbed* self, const gchar* devpath, const gchar* name, const gchar* value);
void umockdev_testbed_set_attribute_binary (UMockdevTestbed* self, const gchar* devpath, const gchar* name, guint8* value, int value_length1);
void umockdev_testbed_set_attribute_int (UMockdevTestbed* self, const gchar* devpath, const gchar* name, gint value);
void umockdev_testbed_set_attribute_hex (UMockdevTestbed* self, const gchar* devpath, const gchar* name, guint value);
void umockdev_testbed_set_attribute_link (UMockdevTestbed* self, const gchar* devpath, const gchar* name, const gchar* value);
void umockdev_testbed_set_property (UMockdevTestbed* self, const gchar* devpath, const gchar* name, const gchar* value);
void umockdev_testbed_set_property_int (UMockdevTestbed* self, const gchar* devpath, const gchar* name, gint value);
void umockdev_testbed_set_property_hex (UMockdevTestbed* self, const gchar* devpath, const gchar* name, guint value);
gchar* umockdev_testbed_add_devicev (UMockdevTestbed* self, const gchar* subsystem, const gchar* name, const gchar* parent, gchar** attributes, gchar** properties);
gchar* umockdev_make_dotdots (const gchar* path);
gchar* umockdev_testbed_add_device (UMockdevTestbed* self, const gchar* subsystem, const gchar* name, const gchar* parent, ...);
static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value);
static void _vala_array_add2 (gchar*** array, int* length, int* size, gchar* value);
void umockdev_testbed_remove_device (UMockdevTestbed* self, const gchar* syspath);
gchar* umockdev_find_devnode (const gchar* devpath);
GQuark umockdev_error_quark (void);
gboolean umockdev_testbed_add_from_string (UMockdevTestbed* self, const gchar* data, GError** error);
static gchar* umockdev_testbed_add_dev_from_string (UMockdevTestbed* self, const gchar* data, GError** error);
gboolean umockdev_testbed_add_from_file (UMockdevTestbed* self, const gchar* path, GError** error);
void umockdev_testbed_uevent (UMockdevTestbed* self, const gchar* devpath, const gchar* action);
gboolean umockdev_testbed_load_ioctl (UMockdevTestbed* self, const gchar* dev, const gchar* recordfile, GError** error);
gboolean umockdev_testbed_load_script (UMockdevTestbed* self, const gchar* dev, const gchar* recordfile, GError** error);
gint umockdev_testbed_get_dev_fd (UMockdevTestbed* self, const gchar* devnode);
UMockdevScriptRunner* umockdev_script_runner_new (const gchar* device, const gchar* script_file, gint fd, GError** error);
UMockdevScriptRunner* umockdev_script_runner_construct (GType object_type, const gchar* device, const gchar* script_file, gint fd, GError** error);
static gchar* umockdev_testbed_record_parse_line (UMockdevTestbed* self, const gchar* data, gchar* type, gchar** key, gchar** val);
static void _vala_array_add3 (gchar*** array, int* length, int* size, gchar* value);
static void _vala_array_add4 (gchar*** array, int* length, int* size, gchar* value);
static void _vala_array_add5 (gchar*** array, int* length, int* size, gchar* value);
static void _vala_array_add6 (gchar*** array, int* length, int* size, gchar* value);
static void _vala_array_add7 (gchar*** array, int* length, int* size, gchar* value);
static void _vala_array_add8 (gchar*** array, int* length, int* size, gchar* value);
static void _vala_array_add9 (gchar*** array, int* length, int* size, gchar* value);
static void _vala_array_add10 (gchar*** array, int* length, int* size, gchar* value);
guint8* umockdev_decode_hex (const gchar* data, int* result_length1, GError** error);
static void umockdev_testbed_create_node_for_device (UMockdevTestbed* self, const gchar* subsystem, const gchar* node_path, guint8* node_contents, int node_contents_length1, GError** error);
void umockdev_testbed_disable (UMockdevTestbed* self);
void umockdev_testbed_enable (UMockdevTestbed* self);
void umockdev_testbed_clear (UMockdevTestbed* self);
static void umockdev_testbed_finalize (GObject* obj);
guint8 umockdev_hexdigit (gchar c);
#define UMOCKDEV_SCRIPT_RUNNER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UMOCKDEV_TYPE_SCRIPT_RUNNER, UMockdevScriptRunnerPrivate))
enum  {
	UMOCKDEV_SCRIPT_RUNNER_DUMMY_PROPERTY
};
static void umockdev_script_runner_set_device (UMockdevScriptRunner* self, const gchar* value);
static void* umockdev_script_runner_run (UMockdevScriptRunner* self);
static gpointer _umockdev_script_runner_run_gthread_func (gpointer self);
const gchar* umockdev_script_runner_get_device (UMockdevScriptRunner* self);
static guint8* umockdev_script_runner_next_line (UMockdevScriptRunner* self, gchar* op, guint32* delta, int* result_length1);
static void umockdev_script_runner_op_write (UMockdevScriptRunner* self, guint8* data, int data_length1, guint32 delta);
static void _vala_array_add11 (guint8** array, int* length, int* size, guint8 value);
static void _vala_array_add12 (guint8** array, int* length, int* size, guint8 value);
static void _vala_array_add13 (guint8** array, int* length, int* size, guint8 value);
static void umockdev_script_runner_finalize (UMockdevScriptRunner* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


/**
     * umockdev_testbed_new:
     *
     * Create a new #UMockdevTestbed object. This is initially empty, call
     * methods like #umockdev_testbed_add_device or
     * #umockdev_testbed_add_from_string to fill it.
     *
     * Returns: The newly created #UMockdevTestbed object.
     */
static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _umockdev_script_runner_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (umockdev_script_runner_unref (var), NULL));
}


UMockdevTestbed* umockdev_testbed_construct (GType object_type) {
	UMockdevTestbed * self = NULL;
	const gchar* _tmp4_;
	gchar* _tmp5_ = NULL;
	const gchar* _tmp6_;
	GHashFunc _tmp7_;
	GEqualFunc _tmp8_;
	GHashTable* _tmp9_;
	GHashFunc _tmp10_;
	GEqualFunc _tmp11_;
	GHashTable* _tmp12_;
	const gchar* _tmp13_;
	const gchar* _tmp14_;
	GError * _inner_error_ = NULL;
	self = (UMockdevTestbed*) g_object_new (object_type, NULL);
	{
		gchar* _tmp0_ = NULL;
		gchar* _tmp1_;
		_tmp0_ = g_dir_make_tmp ("umockdev.XXXXXX", &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch0_g_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_free0 (self->priv->root_dir);
		self->priv->root_dir = _tmp1_;
	}
	goto __finally0;
	__catch0_g_file_error:
	{
		GError* e = NULL;
		FILE* _tmp2_;
		const gchar* _tmp3_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = stderr;
		_tmp3_ = e->message;
		fprintf (_tmp2_, "Cannot create temporary directory: %s\n", _tmp3_);
		abort ();
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp4_ = self->priv->root_dir;
	_tmp5_ = g_build_filename (_tmp4_, "sys", NULL);
	_g_free0 (self->priv->sys_dir);
	self->priv->sys_dir = _tmp5_;
	_tmp6_ = self->priv->sys_dir;
	g_mkdir (_tmp6_, 0755);
	_tmp7_ = g_str_hash;
	_tmp8_ = g_str_equal;
	_tmp9_ = g_hash_table_new_full (_tmp7_, _tmp8_, _g_free0_, NULL);
	_g_hash_table_unref0 (self->priv->dev_fd);
	self->priv->dev_fd = _tmp9_;
	_tmp10_ = g_str_hash;
	_tmp11_ = g_str_equal;
	_tmp12_ = g_hash_table_new_full (_tmp10_, _tmp11_, _g_free0_, _umockdev_script_runner_unref0_);
	_g_hash_table_unref0 (self->priv->dev_script_runner);
	self->priv->dev_script_runner = _tmp12_;
	_tmp13_ = self->priv->root_dir;
	g_setenv ("UMOCKDEV_DIR", _tmp13_, TRUE);
	_tmp14_ = self->priv->root_dir;
	g_debug ("umockdev.vala:77: Created udev test bed %s", _tmp14_);
	return self;
}


UMockdevTestbed* umockdev_testbed_new (void) {
	return umockdev_testbed_construct (UMOCKDEV_TYPE_TESTBED);
}


/**
     * umockdev_testbed_get_root_dir:
     * @self: A #UMockdevTestbed.
     *
     * Get the root directory for the testbed.
     *
     * Returns: The testbed's root directory.
     */
gchar* umockdev_testbed_get_root_dir (UMockdevTestbed* self) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->root_dir;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}


/**
     * umockdev_testbed_get_sys_dir:
     * @self: A #UMockdevTestbed.
     *
     * Get the sysfs directory for the testbed.
     *
     * Returns: The testbed's sysfs directory.
     */
gchar* umockdev_testbed_get_sys_dir (UMockdevTestbed* self) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->sys_dir;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}


/**
     * umockdev_testbed_set_attribute:
     * @self: A #UMockdevTestbed.
     * @devpath: The full device path, as returned by #umockdev_testbed_add_device()
     * @name: Attribute name
     * @value: Attribute string value
     *
     * Set a text sysfs attribute for a device.
     */
static guint8* string_get_data (const gchar* self, int* result_length1) {
	guint8* result;
	guint8* res;
	gint res_length1;
	gint _res_size_;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	guint8* _tmp3_;
	gint _tmp3__length1;
	guint8* _tmp4_;
	gint _tmp4__length1;
	g_return_val_if_fail (self != NULL, NULL);
	res = (guint8*) self;
	res_length1 = -1;
	_res_size_ = res_length1;
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	res_length1 = (gint) _tmp1_;
	_tmp2_ = res_length1;
	_tmp3_ = res;
	_tmp3__length1 = res_length1;
	_tmp4_ = _tmp3_;
	_tmp4__length1 = _tmp3__length1;
	if (result_length1) {
		*result_length1 = _tmp4__length1;
	}
	result = _tmp4_;
	return result;
}


void umockdev_testbed_set_attribute (UMockdevTestbed* self, const gchar* devpath, const gchar* name, const gchar* value) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	guint8* _tmp3_;
	gint _tmp3__length1;
	guint8* _tmp4_;
	gint _tmp4__length1;
	g_return_if_fail (self != NULL);
	g_return_if_fail (devpath != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (value != NULL);
	_tmp0_ = devpath;
	_tmp1_ = name;
	_tmp2_ = value;
	_tmp3_ = string_get_data (_tmp2_, &_tmp3__length1);
	_tmp4_ = _tmp3_;
	_tmp4__length1 = _tmp3__length1;
	umockdev_testbed_set_attribute_binary (self, _tmp0_, _tmp1_, _tmp4_, _tmp4__length1);
}


/**
     * umockdev_testbed_set_attribute_binary:
     * @self: A #UMockdevTestbed.
     * @devpath: The full device path, as returned by #umockdev_testbed_add_device()
     * @name: Attribute name
     * @value: Attribute binary value
     * @value_length1: Length of @value in bytes.
     *
     * Set a binary sysfs attribute for a device.
     */
void umockdev_testbed_set_attribute_binary (UMockdevTestbed* self, const gchar* devpath, const gchar* name, guint8* value, int value_length1) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (devpath != NULL);
	g_return_if_fail (name != NULL);
	{
		const gchar* _tmp0_;
		const gchar* _tmp1_;
		const gchar* _tmp2_;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		guint8* _tmp5_;
		gint _tmp5__length1;
		_tmp0_ = self->priv->root_dir;
		_tmp1_ = devpath;
		_tmp2_ = name;
		_tmp3_ = g_build_filename (_tmp0_, _tmp1_, _tmp2_, NULL);
		_tmp4_ = _tmp3_;
		_tmp5_ = value;
		_tmp5__length1 = value_length1;
		g_file_set_contents (_tmp4_, (const char*) _tmp5_, (size_t) _tmp5__length1, &_inner_error_);
		_g_free0 (_tmp4_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch1_g_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	goto __finally1;
	__catch1_g_file_error:
	{
		GError* e = NULL;
		FILE* _tmp6_;
		const gchar* _tmp7_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = stderr;
		_tmp7_ = e->message;
		fprintf (_tmp6_, "Cannot write attribute file: %s\n", _tmp7_);
		abort ();
		_g_error_free0 (e);
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


/**
     * umockdev_testbed_set_attribute_int:
     * @self: A #UMockdevTestbed.
     * @devpath: The full device path, as returned by #umockdev_testbed_add_device()
     * @name: Attribute name
     * @value: Attribute integer value
     *
     * Set an integer sysfs attribute for a device.
     */
void umockdev_testbed_set_attribute_int (UMockdevTestbed* self, const gchar* devpath, const gchar* name, gint value) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gint _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (devpath != NULL);
	g_return_if_fail (name != NULL);
	_tmp0_ = devpath;
	_tmp1_ = name;
	_tmp2_ = value;
	_tmp3_ = g_strdup_printf ("%i", _tmp2_);
	_tmp4_ = _tmp3_;
	umockdev_testbed_set_attribute (self, _tmp0_, _tmp1_, _tmp4_);
	_g_free0 (_tmp4_);
}


/**
     * umockdev_testbed_set_attribute_hex:
     * @self: A #UMockdevTestbed.
     * @devpath: The full device path, as returned by #umockdev_testbed_add_device()
     * @name: Attribute name
     * @value: Attribute integer value
     *
     * Set an integer sysfs attribute for a device. Set an integer udev
     * property for a device. @value is interpreted as a hexadecimal number.
     * For example, for value==31 this sets the attribute contents to "1f".
     */
void umockdev_testbed_set_attribute_hex (UMockdevTestbed* self, const gchar* devpath, const gchar* name, guint value) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	guint _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (devpath != NULL);
	g_return_if_fail (name != NULL);
	_tmp0_ = devpath;
	_tmp1_ = name;
	_tmp2_ = value;
	_tmp3_ = g_strdup_printf ("%x", _tmp2_);
	_tmp4_ = _tmp3_;
	umockdev_testbed_set_attribute (self, _tmp0_, _tmp1_, _tmp4_);
	_g_free0 (_tmp4_);
}


/**
     * umockdev_testbed_set_attribute_link:
     * @self: A #UMockdevTestbed.
     * @devpath: The full device path, as returned by #umockdev_testbed_add_device()
     * @name: Attribute name
     * @value: Attribute link target value
     *
     * Set a symlink sysfs attribute for a device; this is primarily important
     * for setting "driver" links.
     */
void umockdev_testbed_set_attribute_link (UMockdevTestbed* self, const gchar* devpath, const gchar* name, const gchar* value) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* path;
	const gchar* _tmp4_;
	gint _tmp5_ = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (devpath != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (value != NULL);
	_tmp0_ = self->priv->root_dir;
	_tmp1_ = devpath;
	_tmp2_ = name;
	_tmp3_ = g_build_filename (_tmp0_, _tmp1_, _tmp2_, NULL);
	path = _tmp3_;
	_tmp4_ = value;
	_tmp5_ = symlink (_tmp4_, path);
	if (_tmp5_ < 0) {
		FILE* _tmp6_;
		gint _tmp7_;
		const gchar* _tmp8_ = NULL;
		_tmp6_ = stderr;
		_tmp7_ = errno;
		_tmp8_ = g_strerror (_tmp7_);
		fprintf (_tmp6_, "Cannot create symlink %s: %s\n", path, _tmp8_);
		abort ();
	}
	_g_free0 (path);
}


/**
     * umockdev_testbed_set_property:
     * @self: A #UMockdevTestbed.
     * @devpath: The full device path, as returned by #umockdev_testbed_add_device()
     * @name: Property name
     * @value: Property string value
     *
     * Set a string udev property for a device.
     */
static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* _tmp0_;
	glong _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* end;
	gchar* _tmp3_;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_;
	gboolean _tmp3_;
	glong _tmp9_;
	glong _tmp15_;
	glong _tmp18_;
	glong _tmp19_;
	glong _tmp20_;
	glong _tmp21_;
	glong _tmp22_;
	gchar* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		glong _tmp4_;
		glong _tmp5_;
		glong _tmp6_ = 0L;
		_tmp4_ = offset;
		_tmp5_ = len;
		_tmp6_ = string_strnlen ((gchar*) self, _tmp4_ + _tmp5_);
		string_length = _tmp6_;
	} else {
		gint _tmp7_;
		gint _tmp8_;
		_tmp7_ = strlen (self);
		_tmp8_ = _tmp7_;
		string_length = (glong) _tmp8_;
	}
	_tmp9_ = offset;
	if (_tmp9_ < ((glong) 0)) {
		glong _tmp10_;
		glong _tmp11_;
		glong _tmp12_;
		_tmp10_ = string_length;
		_tmp11_ = offset;
		offset = _tmp10_ + _tmp11_;
		_tmp12_ = offset;
		g_return_val_if_fail (_tmp12_ >= ((glong) 0), NULL);
	} else {
		glong _tmp13_;
		glong _tmp14_;
		_tmp13_ = offset;
		_tmp14_ = string_length;
		g_return_val_if_fail (_tmp13_ <= _tmp14_, NULL);
	}
	_tmp15_ = len;
	if (_tmp15_ < ((glong) 0)) {
		glong _tmp16_;
		glong _tmp17_;
		_tmp16_ = string_length;
		_tmp17_ = offset;
		len = _tmp16_ - _tmp17_;
	}
	_tmp18_ = offset;
	_tmp19_ = len;
	_tmp20_ = string_length;
	g_return_val_if_fail ((_tmp18_ + _tmp19_) <= _tmp20_, NULL);
	_tmp21_ = offset;
	_tmp22_ = len;
	_tmp23_ = g_strndup (((gchar*) self) + _tmp21_, (gsize) _tmp22_);
	result = _tmp23_;
	return result;
}


void umockdev_testbed_set_property (UMockdevTestbed* self, const gchar* devpath, const gchar* name, const gchar* value) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* uevent_path;
	gchar* _tmp3_;
	gchar* props;
	gchar* real_value = NULL;
	gboolean _tmp4_ = FALSE;
	const gchar* _tmp5_;
	gboolean _tmp8_;
	const gchar* _tmp13_;
	GFile* _tmp14_ = NULL;
	GFile* f;
	gboolean existing;
	const gchar* _tmp15_;
	gchar* _tmp16_;
	gchar* prefix;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (devpath != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (value != NULL);
	_tmp0_ = self->priv->root_dir;
	_tmp1_ = devpath;
	_tmp2_ = g_build_filename (_tmp0_, _tmp1_, "uevent", NULL);
	uevent_path = _tmp2_;
	_tmp3_ = g_strdup ("");
	props = _tmp3_;
	_tmp5_ = name;
	if (g_strcmp0 (_tmp5_, "DEVNAME") == 0) {
		const gchar* _tmp6_;
		gboolean _tmp7_ = FALSE;
		_tmp6_ = value;
		_tmp7_ = g_str_has_prefix (_tmp6_, "/dev/");
		_tmp4_ = _tmp7_;
	} else {
		_tmp4_ = FALSE;
	}
	_tmp8_ = _tmp4_;
	if (_tmp8_) {
		const gchar* _tmp9_;
		gchar* _tmp10_ = NULL;
		_tmp9_ = value;
		_tmp10_ = string_substring (_tmp9_, (glong) 5, (glong) (-1));
		_g_free0 (real_value);
		real_value = _tmp10_;
	} else {
		const gchar* _tmp11_;
		gchar* _tmp12_;
		_tmp11_ = value;
		_tmp12_ = g_strdup (_tmp11_);
		_g_free0 (real_value);
		real_value = _tmp12_;
	}
	_tmp13_ = uevent_path;
	_tmp14_ = g_file_new_for_path (_tmp13_);
	f = _tmp14_;
	existing = FALSE;
	_tmp15_ = name;
	_tmp16_ = g_strconcat (_tmp15_, "=", NULL);
	prefix = _tmp16_;
	{
		GFile* _tmp17_;
		GFileInputStream* _tmp18_ = NULL;
		GFileInputStream* _tmp19_;
		GFileInputStream* _tmp20_;
		GDataInputStream* _tmp21_;
		GDataInputStream* _tmp22_;
		GDataInputStream* inp;
		gchar* line = NULL;
		gsize len = 0UL;
		GDataInputStream* _tmp44_;
		gboolean _tmp45_;
		const gchar* _tmp54_;
		const gchar* _tmp55_;
		guint8* _tmp56_;
		gint _tmp56__length1;
		guint8* _tmp57_;
		gint _tmp57__length1;
		_tmp17_ = f;
		_tmp18_ = g_file_read (_tmp17_, NULL, &_inner_error_);
		_tmp19_ = _tmp18_;
		if (_inner_error_ != NULL) {
			goto __catch2_g_error;
		}
		_tmp20_ = _tmp19_;
		_tmp21_ = g_data_input_stream_new ((GInputStream*) _tmp20_);
		_tmp22_ = _tmp21_;
		_g_object_unref0 (_tmp20_);
		inp = _tmp22_;
		while (TRUE) {
			GDataInputStream* _tmp23_;
			gsize _tmp24_ = 0UL;
			gchar* _tmp25_ = NULL;
			gchar* _tmp26_;
			const gchar* _tmp27_;
			const gchar* _tmp28_;
			const gchar* _tmp29_;
			gboolean _tmp30_ = FALSE;
			_tmp23_ = inp;
			_tmp25_ = g_data_input_stream_read_line (_tmp23_, &_tmp24_, NULL, &_inner_error_);
			len = _tmp24_;
			_tmp26_ = _tmp25_;
			if (_inner_error_ != NULL) {
				_g_free0 (line);
				_g_object_unref0 (inp);
				goto __catch2_g_error;
			}
			_g_free0 (line);
			line = _tmp26_;
			_tmp27_ = line;
			if (!(_tmp27_ != NULL)) {
				break;
			}
			_tmp28_ = line;
			_tmp29_ = prefix;
			_tmp30_ = g_str_has_prefix (_tmp28_, _tmp29_);
			if (_tmp30_) {
				const gchar* _tmp31_;
				const gchar* _tmp32_;
				const gchar* _tmp33_;
				gchar* _tmp34_;
				gchar* _tmp35_;
				gchar* _tmp36_;
				gchar* _tmp37_;
				gchar* _tmp38_;
				existing = TRUE;
				_tmp31_ = props;
				_tmp32_ = prefix;
				_tmp33_ = real_value;
				_tmp34_ = g_strconcat (_tmp32_, _tmp33_, NULL);
				_tmp35_ = _tmp34_;
				_tmp36_ = g_strconcat (_tmp35_, "\n", NULL);
				_tmp37_ = _tmp36_;
				_tmp38_ = g_strconcat (_tmp31_, _tmp37_, NULL);
				_g_free0 (props);
				props = _tmp38_;
				_g_free0 (_tmp37_);
				_g_free0 (_tmp35_);
			} else {
				const gchar* _tmp39_;
				const gchar* _tmp40_;
				gchar* _tmp41_;
				gchar* _tmp42_;
				gchar* _tmp43_;
				_tmp39_ = props;
				_tmp40_ = line;
				_tmp41_ = g_strconcat (_tmp40_, "\n", NULL);
				_tmp42_ = _tmp41_;
				_tmp43_ = g_strconcat (_tmp39_, _tmp42_, NULL);
				_g_free0 (props);
				props = _tmp43_;
				_g_free0 (_tmp42_);
			}
		}
		_tmp44_ = inp;
		g_input_stream_close ((GInputStream*) _tmp44_, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_free0 (line);
			_g_object_unref0 (inp);
			goto __catch2_g_error;
		}
		_tmp45_ = existing;
		if (!_tmp45_) {
			const gchar* _tmp46_;
			const gchar* _tmp47_;
			const gchar* _tmp48_;
			gchar* _tmp49_;
			gchar* _tmp50_;
			gchar* _tmp51_;
			gchar* _tmp52_;
			gchar* _tmp53_;
			_tmp46_ = props;
			_tmp47_ = prefix;
			_tmp48_ = real_value;
			_tmp49_ = g_strconcat (_tmp47_, _tmp48_, NULL);
			_tmp50_ = _tmp49_;
			_tmp51_ = g_strconcat (_tmp50_, "\n", NULL);
			_tmp52_ = _tmp51_;
			_tmp53_ = g_strconcat (_tmp46_, _tmp52_, NULL);
			_g_free0 (props);
			props = _tmp53_;
			_g_free0 (_tmp52_);
			_g_free0 (_tmp50_);
		}
		_tmp54_ = uevent_path;
		_tmp55_ = props;
		_tmp56_ = string_get_data (_tmp55_, &_tmp56__length1);
		_tmp57_ = _tmp56_;
		_tmp57__length1 = _tmp56__length1;
		g_file_set_contents (_tmp54_, (const char*) _tmp57_, (size_t) _tmp57__length1, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_free0 (line);
			_g_object_unref0 (inp);
			goto __catch2_g_error;
		}
		_g_free0 (line);
		_g_object_unref0 (inp);
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError* e = NULL;
		FILE* _tmp58_;
		const gchar* _tmp59_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp58_ = stderr;
		_tmp59_ = e->message;
		fprintf (_tmp58_, "Cannot update uevent file: %s\n", _tmp59_);
		abort ();
		_g_error_free0 (e);
	}
	__finally2:
	if (_inner_error_ != NULL) {
		_g_free0 (prefix);
		_g_object_unref0 (f);
		_g_free0 (real_value);
		_g_free0 (props);
		_g_free0 (uevent_path);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_free0 (prefix);
	_g_object_unref0 (f);
	_g_free0 (real_value);
	_g_free0 (props);
	_g_free0 (uevent_path);
}


/**
     * umockdev_testbed_set_property_int:
     * @self: A #UMockdevTestbed.
     * @devpath: The full device path, as returned by #umockdev_testbed_add_device()
     * @name: Property name
     * @value: Property integer value
     *
     * Set an integer udev property for a device.
     */
void umockdev_testbed_set_property_int (UMockdevTestbed* self, const gchar* devpath, const gchar* name, gint value) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gint _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (devpath != NULL);
	g_return_if_fail (name != NULL);
	_tmp0_ = devpath;
	_tmp1_ = name;
	_tmp2_ = value;
	_tmp3_ = g_strdup_printf ("%i", _tmp2_);
	_tmp4_ = _tmp3_;
	umockdev_testbed_set_property (self, _tmp0_, _tmp1_, _tmp4_);
	_g_free0 (_tmp4_);
}


/**
     * umockdev_testbed_set_property_hex:
     * @self: A #UMockdevTestbed.
     * @devpath: The full device path, as returned by #umockdev_testbed_add_device()
     * @name: Property name
     * @value: Property integer value
     *
     * Set an integer udev property for a device. @value is interpreted as a
     * hexadecimal number. For example, for value==31 this sets the property's
     * value to "1f".
     */
void umockdev_testbed_set_property_hex (UMockdevTestbed* self, const gchar* devpath, const gchar* name, guint value) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	guint _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (devpath != NULL);
	g_return_if_fail (name != NULL);
	_tmp0_ = devpath;
	_tmp1_ = name;
	_tmp2_ = value;
	_tmp3_ = g_strdup_printf ("%x", _tmp2_);
	_tmp4_ = _tmp3_;
	umockdev_testbed_set_property (self, _tmp0_, _tmp1_, _tmp4_);
	_g_free0 (_tmp4_);
}


/**
     * umockdev_testbed_add_devicev:
     * @self: A #UMockdevTestbed.
     * @subsystem: The subsystem name, e. g. "usb"
     * @name: The device name; arbitrary, but needs to be unique within the testbed
     * @parent: (allow-none): device path of the parent device. Use %NULL for a
     *          top-level device.
     * @attributes: (array zero-terminated=1):
     *              A list of device sysfs attributes, alternating names and
     *              values, terminated with %NULL:
     *              { "key1", "value1", "key2", "value2", ..., NULL }
     * @properties: (array zero-terminated=1):
     *              A list of device udev properties; same format as @attributes
     *
     * This method is mostly meant for language bindings (where it is named
     * umockdev_testbed_add_device()). For C programs it is usually more convenient to
     * use umockdev_testbed_add_device().
     *
     * Add a new device to the testbed. A Linux kernel device always has a
     * subsystem (such as "usb" or "pci"), and a device name. The test bed only
     * builds a very simple sysfs structure without nested namespaces, so it
     * requires device names to be unique. Some gudev client programs might make
     * assumptions about the name (e. g. a SCSI disk block device should be called
     * sdaN). A device also has an arbitrary number of sysfs attributes and udev
     * properties; usually you should specify them upon creation, but it is also
     * possible to change them later on with umockdev_testbed_set_attribute() and
     * umockdev_testbed_set_property().
     *
     * Returns: The sysfs path for the newly created device. Free with g_free().
     *
     * Rename to: umockdev_testbed_add_device
     */
static gint string_index_of (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gint _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _result_;
	gchar* _tmp3_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = strstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		const gchar* _tmp0_;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_;
		GRegex* _tmp3_;
		GRegex* _tmp4_;
		GRegex* regex;
		GRegex* _tmp5_;
		const gchar* _tmp6_;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch3_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp5_ = regex;
		_tmp6_ = replacement;
		_tmp7_ = g_regex_replace_literal (_tmp5_, self, (gssize) (-1), 0, _tmp6_, 0, &_inner_error_);
		_tmp8_ = _tmp7_;
		if (_inner_error_ != NULL) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch3_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		result = _tmp8_;
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally3;
	__catch3_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally3:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = needle;
	_tmp1_ = strstr ((gchar*) self, (gchar*) _tmp0_);
	result = _tmp1_ != NULL;
	return result;
}


gchar* umockdev_testbed_add_devicev (UMockdevTestbed* self, const gchar* subsystem, const gchar* name, const gchar* parent, gchar** attributes, gchar** properties) {
	gchar* result = NULL;
	gchar* dev_path = NULL;
	gchar* dev_node;
	const gchar* _tmp0_;
	const gchar* _tmp12_;
	const gchar* _tmp13_;
	gchar* _tmp14_ = NULL;
	gchar* dev_dir;
	gboolean _tmp15_ = FALSE;
	const gchar* _tmp16_;
	gboolean _tmp17_ = FALSE;
	gboolean _tmp22_;
	const gchar* _tmp24_;
	gint _tmp25_ = 0;
	const gchar* _tmp29_;
	const gchar* _tmp30_;
	gchar* _tmp31_ = NULL;
	gchar* class_dir;
	const gchar* _tmp32_;
	gint _tmp33_ = 0;
	const gchar* _tmp37_;
	const gchar* _tmp38_;
	gint _tmp39_ = 0;
	gchar* _tmp40_ = NULL;
	gchar* dev_path_no_sys;
	const gchar* _tmp41_;
	gchar* _tmp42_ = NULL;
	gchar* _tmp43_;
	const gchar* _tmp44_;
	gchar* _tmp45_ = NULL;
	gchar* _tmp46_;
	const gchar* _tmp47_;
	gchar* _tmp48_ = NULL;
	gchar* _tmp49_;
	gint _tmp50_ = 0;
	const gchar* _tmp51_;
	gchar* _tmp52_ = NULL;
	gchar* _tmp53_;
	const gchar* _tmp54_;
	const gchar* _tmp55_;
	gchar* _tmp56_ = NULL;
	gchar* _tmp57_;
	gchar* _tmp58_ = NULL;
	gchar* _tmp59_;
	gint _tmp60_ = 0;
	gboolean _tmp61_ = FALSE;
	const gchar* _tmp62_;
	gboolean _tmp64_;
	gchar* _tmp80_;
	gchar* props;
	gchar** _tmp120_;
	gint _tmp120__length1;
	const gchar* _tmp124_;
	const gchar* _tmp125_;
	gchar** _tmp180_;
	gint _tmp180__length1;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (subsystem != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	dev_node = NULL;
	_tmp0_ = parent;
	if (_tmp0_ != NULL) {
		const gchar* _tmp1_;
		gboolean _tmp2_ = FALSE;
		const gchar* _tmp4_;
		gboolean _tmp5_ = FALSE;
		const gchar* _tmp7_;
		const gchar* _tmp8_;
		gchar* _tmp9_ = NULL;
		_tmp1_ = parent;
		_tmp2_ = g_str_has_prefix (_tmp1_, "/sys/");
		if (!_tmp2_) {
			const gchar* _tmp3_;
			_tmp3_ = parent;
			g_critical ("umockdev.vala:329: add_devicev(): parent device %s does not start with" \
" /sys/", _tmp3_);
			result = NULL;
			_g_free0 (dev_node);
			_g_free0 (dev_path);
			return result;
		}
		_tmp4_ = parent;
		_tmp5_ = g_file_test (_tmp4_, G_FILE_TEST_IS_DIR);
		if (!_tmp5_) {
			const gchar* _tmp6_;
			_tmp6_ = parent;
			g_critical ("umockdev.vala:333: add_devicev(): parent device %s does not exist", _tmp6_);
			result = NULL;
			_g_free0 (dev_node);
			_g_free0 (dev_path);
			return result;
		}
		_tmp7_ = parent;
		_tmp8_ = name;
		_tmp9_ = g_build_filename (_tmp7_, _tmp8_, NULL);
		_g_free0 (dev_path);
		dev_path = _tmp9_;
	} else {
		const gchar* _tmp10_;
		gchar* _tmp11_ = NULL;
		_tmp10_ = name;
		_tmp11_ = g_build_filename ("/sys/devices", _tmp10_, NULL);
		_g_free0 (dev_path);
		dev_path = _tmp11_;
	}
	_tmp12_ = self->priv->root_dir;
	_tmp13_ = dev_path;
	_tmp14_ = g_build_filename (_tmp12_, _tmp13_, NULL);
	dev_dir = _tmp14_;
	_tmp16_ = dev_dir;
	_tmp17_ = g_file_test (_tmp16_, G_FILE_TEST_EXISTS);
	if (_tmp17_) {
		const gchar* _tmp18_;
		gchar* _tmp19_ = NULL;
		gchar* _tmp20_;
		gboolean _tmp21_ = FALSE;
		_tmp18_ = dev_dir;
		_tmp19_ = g_build_filename (_tmp18_, "uevent", NULL);
		_tmp20_ = _tmp19_;
		_tmp21_ = g_file_test (_tmp20_, G_FILE_TEST_EXISTS);
		_tmp15_ = _tmp21_;
		_g_free0 (_tmp20_);
	} else {
		_tmp15_ = FALSE;
	}
	_tmp22_ = _tmp15_;
	if (_tmp22_) {
		const gchar* _tmp23_;
		_tmp23_ = dev_dir;
		g_error ("umockdev.vala:344: device %s already exists", _tmp23_);
	}
	_tmp24_ = dev_dir;
	_tmp25_ = g_mkdir_with_parents (_tmp24_, 0755);
	if (_tmp25_ != 0) {
		const gchar* _tmp26_;
		gint _tmp27_;
		const gchar* _tmp28_ = NULL;
		_tmp26_ = dev_dir;
		_tmp27_ = errno;
		_tmp28_ = g_strerror (_tmp27_);
		g_error ("umockdev.vala:348: cannot create dev dir '%s': %s", _tmp26_, _tmp28_);
	}
	_tmp29_ = self->priv->sys_dir;
	_tmp30_ = subsystem;
	_tmp31_ = g_build_filename (_tmp29_, "class", _tmp30_, NULL);
	class_dir = _tmp31_;
	_tmp32_ = class_dir;
	_tmp33_ = g_mkdir_with_parents (_tmp32_, 0755);
	if (_tmp33_ != 0) {
		const gchar* _tmp34_;
		gint _tmp35_;
		const gchar* _tmp36_ = NULL;
		_tmp34_ = class_dir;
		_tmp35_ = errno;
		_tmp36_ = g_strerror (_tmp35_);
		g_error ("umockdev.vala:351: cannot create class dir '%s': %s", _tmp34_, _tmp36_);
	}
	_tmp37_ = dev_path;
	_tmp38_ = dev_path;
	_tmp39_ = string_index_of (_tmp38_, "/devices/", 0);
	_tmp40_ = string_substring (_tmp37_, (glong) _tmp39_, (glong) (-1));
	dev_path_no_sys = _tmp40_;
	_tmp41_ = dev_path;
	_tmp42_ = umockdev_make_dotdots (_tmp41_);
	_tmp43_ = _tmp42_;
	_tmp44_ = subsystem;
	_tmp45_ = g_build_filename (_tmp43_, "class", _tmp44_, NULL);
	_tmp46_ = _tmp45_;
	_tmp47_ = dev_dir;
	_tmp48_ = g_build_filename (_tmp47_, "subsystem", NULL);
	_tmp49_ = _tmp48_;
	_tmp50_ = symlink (_tmp46_, _tmp49_);
	_vala_assert (_tmp50_ == 0, "FileUtils.symlink(Path.build_filename(make_dotdots(dev_path), \"class\", subsystem),                                  Path.build_filename(dev_dir, \"subsystem\")) == 0");
	_g_free0 (_tmp49_);
	_g_free0 (_tmp46_);
	_g_free0 (_tmp43_);
	_tmp51_ = dev_path_no_sys;
	_tmp52_ = g_build_filename ("..", "..", _tmp51_, NULL);
	_tmp53_ = _tmp52_;
	_tmp54_ = class_dir;
	_tmp55_ = name;
	_tmp56_ = g_path_get_basename (_tmp55_);
	_tmp57_ = _tmp56_;
	_tmp58_ = g_build_filename (_tmp54_, _tmp57_, NULL);
	_tmp59_ = _tmp58_;
	_tmp60_ = symlink (_tmp53_, _tmp59_);
	_vala_assert (_tmp60_ == 0, "FileUtils.symlink(Path.build_filename(\"..\", \"..\", dev_path_no_sys),                                  Path.build_filename(class_dir, Path.get_basename(name))) == 0");
	_g_free0 (_tmp59_);
	_g_free0 (_tmp57_);
	_g_free0 (_tmp53_);
	_tmp62_ = subsystem;
	if (g_strcmp0 (_tmp62_, "usb") == 0) {
		_tmp61_ = TRUE;
	} else {
		const gchar* _tmp63_;
		_tmp63_ = subsystem;
		_tmp61_ = g_strcmp0 (_tmp63_, "pci") == 0;
	}
	_tmp64_ = _tmp61_;
	if (_tmp64_) {
		const gchar* _tmp65_;
		const gchar* _tmp66_;
		gchar* _tmp67_ = NULL;
		const gchar* _tmp68_;
		gint _tmp69_ = 0;
		const gchar* _tmp70_;
		gchar* _tmp71_ = NULL;
		gchar* _tmp72_;
		const gchar* _tmp73_;
		const gchar* _tmp74_;
		gchar* _tmp75_ = NULL;
		gchar* _tmp76_;
		gchar* _tmp77_ = NULL;
		gchar* _tmp78_;
		gint _tmp79_ = 0;
		_tmp65_ = self->priv->sys_dir;
		_tmp66_ = subsystem;
		_tmp67_ = g_build_filename (_tmp65_, "bus", _tmp66_, "devices", NULL);
		_g_free0 (class_dir);
		class_dir = _tmp67_;
		_tmp68_ = class_dir;
		_tmp69_ = g_mkdir_with_parents (_tmp68_, 0755);
		_vala_assert (_tmp69_ == 0, "DirUtils.create_with_parents(class_dir, 0755) == 0");
		_tmp70_ = dev_path_no_sys;
		_tmp71_ = g_build_filename ("..", "..", "..", _tmp70_, NULL);
		_tmp72_ = _tmp71_;
		_tmp73_ = class_dir;
		_tmp74_ = name;
		_tmp75_ = g_path_get_basename (_tmp74_);
		_tmp76_ = _tmp75_;
		_tmp77_ = g_build_filename (_tmp73_, _tmp76_, NULL);
		_tmp78_ = _tmp77_;
		_tmp79_ = symlink (_tmp72_, _tmp78_);
		_vala_assert (_tmp79_ == 0, "FileUtils.symlink(Path.build_filename(\"..\", \"..\", \"..\", dev_path_no_sys),                                      Path.build_filename(class_dir, Path.get_basename(name))) == 0");
		_g_free0 (_tmp78_);
		_g_free0 (_tmp76_);
		_g_free0 (_tmp72_);
	}
	_tmp80_ = g_strdup ("");
	props = _tmp80_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp81_;
			_tmp81_ = TRUE;
			while (TRUE) {
				gboolean _tmp82_;
				gint _tmp84_;
				gchar** _tmp85_;
				gint _tmp85__length1;
				gboolean _tmp86_ = FALSE;
				gchar** _tmp87_;
				gint _tmp87__length1;
				gint _tmp88_;
				const gchar* _tmp89_;
				gboolean _tmp94_;
				_tmp82_ = _tmp81_;
				if (!_tmp82_) {
					gint _tmp83_;
					_tmp83_ = i;
					i = _tmp83_ + 2;
				}
				_tmp81_ = FALSE;
				_tmp84_ = i;
				_tmp85_ = properties;
				_tmp85__length1 = _vala_array_length (properties);
				if (!(_tmp84_ < (_tmp85__length1 - 1))) {
					break;
				}
				_tmp87_ = properties;
				_tmp87__length1 = _vala_array_length (properties);
				_tmp88_ = i;
				_tmp89_ = _tmp87_[_tmp88_];
				if (g_strcmp0 (_tmp89_, "DEVNAME") == 0) {
					gchar** _tmp90_;
					gint _tmp90__length1;
					gint _tmp91_;
					const gchar* _tmp92_;
					gboolean _tmp93_ = FALSE;
					_tmp90_ = properties;
					_tmp90__length1 = _vala_array_length (properties);
					_tmp91_ = i;
					_tmp92_ = _tmp90_[_tmp91_ + 1];
					_tmp93_ = g_str_has_prefix (_tmp92_, "/dev/");
					_tmp86_ = _tmp93_;
				} else {
					_tmp86_ = FALSE;
				}
				_tmp94_ = _tmp86_;
				if (_tmp94_) {
					gchar** _tmp95_;
					gint _tmp95__length1;
					gint _tmp96_;
					const gchar* _tmp97_;
					gchar* _tmp98_ = NULL;
					const gchar* _tmp99_;
					const gchar* _tmp100_;
					gchar* _tmp101_;
					gchar* _tmp102_;
					gchar* _tmp103_;
					gchar* _tmp104_;
					gchar* _tmp105_;
					_tmp95_ = properties;
					_tmp95__length1 = _vala_array_length (properties);
					_tmp96_ = i;
					_tmp97_ = _tmp95_[_tmp96_ + 1];
					_tmp98_ = string_substring (_tmp97_, (glong) 5, (glong) (-1));
					_g_free0 (dev_node);
					dev_node = _tmp98_;
					_tmp99_ = props;
					_tmp100_ = dev_node;
					_tmp101_ = g_strconcat ("DEVNAME=", _tmp100_, NULL);
					_tmp102_ = _tmp101_;
					_tmp103_ = g_strconcat (_tmp102_, "\n", NULL);
					_tmp104_ = _tmp103_;
					_tmp105_ = g_strconcat (_tmp99_, _tmp104_, NULL);
					_g_free0 (props);
					props = _tmp105_;
					_g_free0 (_tmp104_);
					_g_free0 (_tmp102_);
				} else {
					const gchar* _tmp106_;
					gchar** _tmp107_;
					gint _tmp107__length1;
					gint _tmp108_;
					const gchar* _tmp109_;
					gchar* _tmp110_;
					gchar* _tmp111_;
					gchar** _tmp112_;
					gint _tmp112__length1;
					gint _tmp113_;
					const gchar* _tmp114_;
					gchar* _tmp115_;
					gchar* _tmp116_;
					gchar* _tmp117_;
					gchar* _tmp118_;
					gchar* _tmp119_;
					_tmp106_ = props;
					_tmp107_ = properties;
					_tmp107__length1 = _vala_array_length (properties);
					_tmp108_ = i;
					_tmp109_ = _tmp107_[_tmp108_];
					_tmp110_ = g_strconcat (_tmp109_, "=", NULL);
					_tmp111_ = _tmp110_;
					_tmp112_ = properties;
					_tmp112__length1 = _vala_array_length (properties);
					_tmp113_ = i;
					_tmp114_ = _tmp112_[_tmp113_ + 1];
					_tmp115_ = g_strconcat (_tmp111_, _tmp114_, NULL);
					_tmp116_ = _tmp115_;
					_tmp117_ = g_strconcat (_tmp116_, "\n", NULL);
					_tmp118_ = _tmp117_;
					_tmp119_ = g_strconcat (_tmp106_, _tmp118_, NULL);
					_g_free0 (props);
					props = _tmp119_;
					_g_free0 (_tmp118_);
					_g_free0 (_tmp116_);
					_g_free0 (_tmp111_);
				}
			}
		}
	}
	_tmp120_ = properties;
	_tmp120__length1 = _vala_array_length (properties);
	if ((_tmp120__length1 % 2) != 0) {
		gchar** _tmp121_;
		gint _tmp121__length1;
		gchar** _tmp122_;
		gint _tmp122__length1;
		const gchar* _tmp123_;
		_tmp121_ = properties;
		_tmp121__length1 = _vala_array_length (properties);
		_tmp122_ = properties;
		_tmp122__length1 = _vala_array_length (properties);
		_tmp123_ = _tmp121_[_tmp122__length1 - 1];
		g_warning ("umockdev.vala:383: add_devicev: Ignoring property key '%s' without val" \
"ue", _tmp123_);
	}
	_tmp124_ = dev_path;
	_tmp125_ = props;
	umockdev_testbed_set_attribute (self, _tmp124_, "uevent", _tmp125_);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp126_;
			_tmp126_ = TRUE;
			while (TRUE) {
				gboolean _tmp127_;
				gint _tmp129_;
				gchar** _tmp130_;
				gint _tmp130__length1;
				const gchar* _tmp131_;
				gchar** _tmp132_;
				gint _tmp132__length1;
				gint _tmp133_;
				const gchar* _tmp134_;
				gchar** _tmp135_;
				gint _tmp135__length1;
				gint _tmp136_;
				const gchar* _tmp137_;
				gboolean _tmp138_ = FALSE;
				gchar** _tmp139_;
				gint _tmp139__length1;
				gint _tmp140_;
				const gchar* _tmp141_;
				gboolean _tmp143_;
				_tmp127_ = _tmp126_;
				if (!_tmp127_) {
					gint _tmp128_;
					_tmp128_ = i;
					i = _tmp128_ + 2;
				}
				_tmp126_ = FALSE;
				_tmp129_ = i;
				_tmp130_ = attributes;
				_tmp130__length1 = _vala_array_length (attributes);
				if (!(_tmp129_ < (_tmp130__length1 - 1))) {
					break;
				}
				_tmp131_ = dev_path;
				_tmp132_ = attributes;
				_tmp132__length1 = _vala_array_length (attributes);
				_tmp133_ = i;
				_tmp134_ = _tmp132_[_tmp133_];
				_tmp135_ = attributes;
				_tmp135__length1 = _vala_array_length (attributes);
				_tmp136_ = i;
				_tmp137_ = _tmp135_[_tmp136_ + 1];
				umockdev_testbed_set_attribute (self, _tmp131_, _tmp134_, _tmp137_);
				_tmp139_ = attributes;
				_tmp139__length1 = _vala_array_length (attributes);
				_tmp140_ = i;
				_tmp141_ = _tmp139_[_tmp140_];
				if (g_strcmp0 (_tmp141_, "dev") == 0) {
					const gchar* _tmp142_;
					_tmp142_ = dev_node;
					_tmp138_ = _tmp142_ != NULL;
				} else {
					_tmp138_ = FALSE;
				}
				_tmp143_ = _tmp138_;
				if (_tmp143_) {
					const gchar* _tmp144_;
					gchar* _tmp145_ = NULL;
					gchar* infodir;
					const gchar* _tmp146_;
					gchar** _tmp147_;
					gint _tmp147__length1;
					gint _tmp148_;
					const gchar* _tmp149_;
					const gchar* _tmp150_;
					const gchar* _tmp151_;
					gchar* _tmp152_ = NULL;
					gchar* _tmp153_;
					gchar* _tmp154_ = NULL;
					gchar* _tmp155_;
					gint _tmp156_ = 0;
					const gchar* _tmp157_ = NULL;
					const gchar* _tmp158_;
					gboolean _tmp159_ = FALSE;
					const gchar* _tmp160_;
					const gchar* _tmp161_;
					gchar* _tmp162_ = NULL;
					gchar* sysdev_dir;
					const gchar* _tmp163_;
					gint _tmp164_ = 0;
					const gchar* _tmp168_;
					gchar* _tmp169_ = NULL;
					gchar* _tmp170_;
					gchar* _tmp171_;
					gchar* _tmp172_;
					const gchar* _tmp173_;
					gchar** _tmp174_;
					gint _tmp174__length1;
					gint _tmp175_;
					const gchar* _tmp176_;
					gchar* _tmp177_ = NULL;
					gchar* _tmp178_;
					gint _tmp179_ = 0;
					_tmp144_ = self->priv->root_dir;
					_tmp145_ = g_build_filename (_tmp144_, "dev", ".node", NULL);
					infodir = _tmp145_;
					_tmp146_ = infodir;
					g_mkdir_with_parents (_tmp146_, 0755);
					_tmp147_ = attributes;
					_tmp147__length1 = _vala_array_length (attributes);
					_tmp148_ = i;
					_tmp149_ = _tmp147_[_tmp148_ + 1];
					_tmp150_ = infodir;
					_tmp151_ = dev_node;
					_tmp152_ = string_replace (_tmp151_, "/", "_");
					_tmp153_ = _tmp152_;
					_tmp154_ = g_build_filename (_tmp150_, _tmp153_, NULL);
					_tmp155_ = _tmp154_;
					_tmp156_ = symlink (_tmp149_, _tmp155_);
					_vala_assert (_tmp156_ == 0, "FileUtils.symlink(attributes[i+1],                                          Path.build_filename(infodir, dev_node.replace(\"/\", \"_\"))) == 0");
					_g_free0 (_tmp155_);
					_g_free0 (_tmp153_);
					_tmp158_ = dev_path;
					_tmp159_ = string_contains (_tmp158_, "/block/");
					if (_tmp159_) {
						_tmp157_ = "block";
					} else {
						_tmp157_ = "char";
					}
					_tmp160_ = self->priv->sys_dir;
					_tmp161_ = _tmp157_;
					_tmp162_ = g_build_filename (_tmp160_, "dev", _tmp161_, NULL);
					sysdev_dir = _tmp162_;
					_tmp163_ = sysdev_dir;
					_tmp164_ = g_mkdir_with_parents (_tmp163_, 0755);
					if (_tmp164_ != 0) {
						const gchar* _tmp165_;
						gint _tmp166_;
						const gchar* _tmp167_ = NULL;
						_tmp165_ = sysdev_dir;
						_tmp166_ = errno;
						_tmp167_ = g_strerror (_tmp166_);
						g_error ("umockdev.vala:400: cannot create dir '%s': %s", _tmp165_, _tmp167_);
					}
					_tmp168_ = dev_path;
					_tmp169_ = string_substring (_tmp168_, (glong) 5, (glong) (-1));
					_tmp170_ = _tmp169_;
					_tmp171_ = g_strconcat ("../../", _tmp170_, NULL);
					_tmp172_ = _tmp171_;
					_tmp173_ = sysdev_dir;
					_tmp174_ = attributes;
					_tmp174__length1 = _vala_array_length (attributes);
					_tmp175_ = i;
					_tmp176_ = _tmp174_[_tmp175_ + 1];
					_tmp177_ = g_build_filename (_tmp173_, _tmp176_, NULL);
					_tmp178_ = _tmp177_;
					_tmp179_ = symlink (_tmp172_, _tmp178_);
					_vala_assert (_tmp179_ == 0, "FileUtils.symlink(\"../../\" + dev_path.substring(5),                                          Path.build_filename(sysdev_dir, attributes[i+1])) == 0");
					_g_free0 (_tmp178_);
					_g_free0 (_tmp172_);
					_g_free0 (_tmp170_);
					_g_free0 (sysdev_dir);
					_g_free0 (infodir);
				}
			}
		}
	}
	_tmp180_ = attributes;
	_tmp180__length1 = _vala_array_length (attributes);
	if ((_tmp180__length1 % 2) != 0) {
		gchar** _tmp181_;
		gint _tmp181__length1;
		gchar** _tmp182_;
		gint _tmp182__length1;
		const gchar* _tmp183_;
		_tmp181_ = attributes;
		_tmp181__length1 = _vala_array_length (attributes);
		_tmp182_ = attributes;
		_tmp182__length1 = _vala_array_length (attributes);
		_tmp183_ = _tmp181_[_tmp182__length1 - 1];
		g_warning ("umockdev.vala:406: add_devicev: Ignoring attribute key '%s' without va" \
"lue", _tmp183_);
	}
	result = dev_path;
	_g_free0 (props);
	_g_free0 (dev_path_no_sys);
	_g_free0 (class_dir);
	_g_free0 (dev_dir);
	_g_free0 (dev_node);
	return result;
}


/**
     * umockdev_testbed_add_device: (skip)
     * @self: A #UMockdevTestbed.
     * @subsystem: The subsystem name, e. g. "usb"
     * @name: The device name; arbitrary, but needs to be unique within the testbed
     * @parent: (allow-none): device path of the parent device. Use %NULL for a
     *          top-level device.
     * @...: Arbitrarily many pairs of sysfs attributes (alternating names and
     *       values), terminated by %NULL, followed by arbitrarily many pairs of udev
     *       properties, terminated by another %NULL.
     *
     * Add a new device to the testbed. A Linux kernel device always has a
     * subsystem (such as "usb" or "pci"), and a device name. The test bed only
     * builds a very simple sysfs structure without nested namespaces, so it
     * requires device names to be unique. Some gudev client programs might make
     * assumptions about the name (e. g. a SCSI disk block device should be called
     * sdaN). A device also has an arbitrary number of sysfs attributes and udev
     * properties; usually you should specify them upon creation, but it is also
     * possible to change them later on with umockdev_testbed_set_attribute() and
     * umockdev_testbed_set_property().
     *
     * Example:
     *   |[
     *   umockdev_testbed_add_device (testbed, "usb", "dev1", NULL,
     *                              "idVendor", "0815", "idProduct", "AFFE", NULL,
     *                              "ID_MODEL", "KoolGadget", NULL);
     *   ]|
     *
     * Returns: The sysfs path for the newly created device. Free with g_free().
     */
static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add2 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


gchar* umockdev_testbed_add_device (UMockdevTestbed* self, const gchar* subsystem, const gchar* name, const gchar* parent, ...) {
	gchar* result = NULL;
	gchar** _tmp0_ = NULL;
	gchar** attributes;
	gint attributes_length1;
	gint _attributes_size_;
	gchar** _tmp1_ = NULL;
	gchar** properties;
	gint properties_length1;
	gint _properties_size_;
	gint arg_set;
	va_list l = {0};
	const gchar* _tmp14_;
	const gchar* _tmp15_;
	const gchar* _tmp16_;
	gchar** _tmp17_;
	gint _tmp17__length1;
	gchar** _tmp18_;
	gint _tmp18__length1;
	gchar* _tmp19_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (subsystem != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = g_new0 (gchar*, 0 + 1);
	attributes = _tmp0_;
	attributes_length1 = 0;
	_attributes_size_ = attributes_length1;
	_tmp1_ = g_new0 (gchar*, 0 + 1);
	properties = _tmp1_;
	properties_length1 = 0;
	_properties_size_ = properties_length1;
	arg_set = 0;
	va_start (l, parent);
	while (TRUE) {
		const gchar* _tmp2_ = NULL;
		gchar* _tmp3_;
		gchar* arg;
		const gchar* _tmp4_;
		gint _tmp7_;
		_tmp2_ = va_arg (l, gchar*);
		_tmp3_ = g_strdup (_tmp2_);
		arg = _tmp3_;
		_tmp4_ = arg;
		if (_tmp4_ == NULL) {
			gint _tmp5_;
			gint _tmp6_;
			_tmp5_ = arg_set;
			arg_set = _tmp5_ + 1;
			_tmp6_ = arg_set;
			if (_tmp6_ > 1) {
				_g_free0 (arg);
				break;
			} else {
				_g_free0 (arg);
				continue;
			}
		}
		_tmp7_ = arg_set;
		if (_tmp7_ == 0) {
			gchar** _tmp8_;
			gint _tmp8__length1;
			const gchar* _tmp9_;
			gchar* _tmp10_;
			_tmp8_ = attributes;
			_tmp8__length1 = attributes_length1;
			_tmp9_ = arg;
			_tmp10_ = g_strdup (_tmp9_);
			_vala_array_add1 (&attributes, &attributes_length1, &_attributes_size_, _tmp10_);
		} else {
			gchar** _tmp11_;
			gint _tmp11__length1;
			const gchar* _tmp12_;
			gchar* _tmp13_;
			_tmp11_ = properties;
			_tmp11__length1 = properties_length1;
			_tmp12_ = arg;
			_tmp13_ = g_strdup (_tmp12_);
			_vala_array_add2 (&properties, &properties_length1, &_properties_size_, _tmp13_);
		}
		_g_free0 (arg);
	}
	_tmp14_ = subsystem;
	_tmp15_ = name;
	_tmp16_ = parent;
	_tmp17_ = attributes;
	_tmp17__length1 = attributes_length1;
	_tmp18_ = properties;
	_tmp18__length1 = properties_length1;
	_tmp19_ = umockdev_testbed_add_devicev (self, _tmp14_, _tmp15_, _tmp16_, _tmp17_, _tmp18_);
	result = _tmp19_;
	va_end (l);
	properties = (_vala_array_free (properties, properties_length1, (GDestroyNotify) g_free), NULL);
	attributes = (_vala_array_free (attributes, attributes_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


/**
     * umockdev_testbed_remove_device:
     * @self: A #UMockdevTestbed.
     * @syspath: Sysfs path of device
     *
     * Remove a device from the testbed. This removes the sysfs directory, the
     * /sys/class/ link, the device node, and all other information related to
     * it. Note that this will also remove all child devices (i. e.
     * subdirectories of @syspath).
     */
void umockdev_testbed_remove_device (UMockdevTestbed* self, const gchar* syspath) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* real_path;
	const gchar* _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* devname;
	const gchar* _tmp5_;
	gboolean _tmp6_ = FALSE;
	gchar* subsystem = NULL;
	const gchar* _tmp49_;
	const gchar* _tmp50_;
	const gchar* _tmp51_;
	gchar* _tmp52_ = NULL;
	gchar* _tmp53_;
	const gchar* _tmp54_;
	const gchar* _tmp55_;
	gchar* _tmp56_ = NULL;
	gchar* _tmp57_;
	gboolean _tmp58_ = FALSE;
	const gchar* _tmp59_;
	gboolean _tmp61_;
	const gchar* _tmp75_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (syspath != NULL);
	_tmp0_ = self->priv->root_dir;
	_tmp1_ = syspath;
	_tmp2_ = g_build_filename (_tmp0_, _tmp1_, NULL);
	real_path = _tmp2_;
	_tmp3_ = syspath;
	_tmp4_ = g_path_get_basename (_tmp3_);
	devname = _tmp4_;
	_tmp5_ = real_path;
	_tmp6_ = g_file_test (_tmp5_, G_FILE_TEST_IS_DIR);
	if (!_tmp6_) {
		const gchar* _tmp7_;
		_tmp7_ = syspath;
		g_critical ("umockdev.vala:483: umockdev_testbed_remove_device(): device %s does no" \
"t exist", _tmp7_);
		_g_free0 (devname);
		_g_free0 (real_path);
		return;
	}
	{
		const gchar* _tmp8_;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		gchar* _tmp11_ = NULL;
		gchar* _tmp12_;
		gchar* _tmp13_;
		gchar* _tmp14_;
		gchar* _tmp15_ = NULL;
		_tmp8_ = real_path;
		_tmp9_ = g_build_filename (_tmp8_, "subsystem", NULL);
		_tmp10_ = _tmp9_;
		_tmp11_ = g_file_read_link (_tmp10_, &_inner_error_);
		_tmp12_ = _tmp11_;
		_g_free0 (_tmp10_);
		_tmp13_ = _tmp12_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch4_g_file_error;
			}
			_g_free0 (subsystem);
			_g_free0 (devname);
			_g_free0 (real_path);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp14_ = _tmp13_;
		_tmp15_ = g_path_get_basename (_tmp14_);
		_g_free0 (subsystem);
		subsystem = _tmp15_;
		_g_free0 (_tmp14_);
	}
	goto __finally4;
	__catch4_g_file_error:
	{
		GError* e = NULL;
		const gchar* _tmp16_;
		GError* _tmp17_;
		const gchar* _tmp18_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp16_ = syspath;
		_tmp17_ = e;
		_tmp18_ = _tmp17_->message;
		g_critical ("umockdev.vala:493: umockdev_testbed_remove_device(): cannot determine " \
"subsystem of %s: %s", _tmp16_, _tmp18_);
		_g_error_free0 (e);
		_g_free0 (subsystem);
		_g_free0 (devname);
		_g_free0 (real_path);
		return;
	}
	__finally4:
	if (_inner_error_ != NULL) {
		_g_free0 (subsystem);
		_g_free0 (devname);
		_g_free0 (real_path);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		gchar* dev_maj_min = NULL;
		const gchar* _tmp19_;
		gchar* _tmp20_ = NULL;
		gchar* _tmp21_;
		gchar* _tmp22_ = NULL;
		const gchar* _tmp23_ = NULL;
		const gchar* _tmp24_;
		gboolean _tmp25_ = FALSE;
		const gchar* _tmp26_;
		const gchar* _tmp27_;
		const gchar* _tmp28_;
		gchar* _tmp29_ = NULL;
		gchar* _tmp30_;
		const gchar* _tmp31_;
		gchar* _tmp32_ = NULL;
		gchar* dev_node;
		const gchar* _tmp33_;
		_tmp19_ = real_path;
		_tmp20_ = g_build_filename (_tmp19_, "dev", NULL);
		_tmp21_ = _tmp20_;
		g_file_get_contents (_tmp21_, &_tmp22_, NULL, &_inner_error_);
		_g_free0 (dev_maj_min);
		dev_maj_min = _tmp22_;
		_g_free0 (_tmp21_);
		if (_inner_error_ != NULL) {
			_g_free0 (dev_maj_min);
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch5_g_file_error;
			}
			_g_free0 (dev_maj_min);
			_g_free0 (subsystem);
			_g_free0 (devname);
			_g_free0 (real_path);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp24_ = syspath;
		_tmp25_ = string_contains (_tmp24_, "/block/");
		if (_tmp25_) {
			_tmp23_ = "block";
		} else {
			_tmp23_ = "char";
		}
		_tmp26_ = self->priv->sys_dir;
		_tmp27_ = _tmp23_;
		_tmp28_ = dev_maj_min;
		_tmp29_ = g_build_filename (_tmp26_, "dev", _tmp27_, _tmp28_, NULL);
		_tmp30_ = _tmp29_;
		g_unlink (_tmp30_);
		_g_free0 (_tmp30_);
		_tmp31_ = real_path;
		_tmp32_ = umockdev_find_devnode (_tmp31_);
		dev_node = _tmp32_;
		_tmp33_ = dev_node;
		if (_tmp33_ != NULL) {
			const gchar* _tmp34_;
			const gchar* _tmp35_;
			gchar* _tmp36_ = NULL;
			gchar* real_node;
			const gchar* _tmp37_;
			const gchar* _tmp38_;
			gchar* _tmp39_ = NULL;
			gchar* _tmp40_;
			const gchar* _tmp41_;
			const gchar* _tmp42_;
			gchar* _tmp43_ = NULL;
			gchar* _tmp44_;
			gchar* _tmp45_ = NULL;
			gchar* _tmp46_;
			gchar* _tmp47_ = NULL;
			gchar* _tmp48_;
			_tmp34_ = self->priv->root_dir;
			_tmp35_ = dev_node;
			_tmp36_ = g_build_filename (_tmp34_, _tmp35_, NULL);
			real_node = _tmp36_;
			_tmp37_ = real_node;
			g_unlink (_tmp37_);
			_tmp38_ = real_node;
			_tmp39_ = g_path_get_dirname (_tmp38_);
			_tmp40_ = _tmp39_;
			g_rmdir (_tmp40_);
			_g_free0 (_tmp40_);
			_tmp41_ = self->priv->root_dir;
			_tmp42_ = dev_node;
			_tmp43_ = string_substring (_tmp42_, (glong) 5, (glong) (-1));
			_tmp44_ = _tmp43_;
			_tmp45_ = string_replace (_tmp44_, "/", "_");
			_tmp46_ = _tmp45_;
			_tmp47_ = g_build_filename (_tmp41_, "dev", ".node", _tmp46_, NULL);
			_tmp48_ = _tmp47_;
			g_unlink (_tmp48_);
			_g_free0 (_tmp48_);
			_g_free0 (_tmp46_);
			_g_free0 (_tmp44_);
			_g_free0 (real_node);
		}
		_g_free0 (dev_node);
		_g_free0 (dev_maj_min);
	}
	goto __finally5;
	__catch5_g_file_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally5:
	if (_inner_error_ != NULL) {
		_g_free0 (subsystem);
		_g_free0 (devname);
		_g_free0 (real_path);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp49_ = self->priv->sys_dir;
	_tmp50_ = subsystem;
	_tmp51_ = devname;
	_tmp52_ = g_build_filename (_tmp49_, "class", _tmp50_, _tmp51_, NULL);
	_tmp53_ = _tmp52_;
	g_unlink (_tmp53_);
	_g_free0 (_tmp53_);
	_tmp54_ = self->priv->sys_dir;
	_tmp55_ = subsystem;
	_tmp56_ = g_build_filename (_tmp54_, "class", _tmp55_, NULL);
	_tmp57_ = _tmp56_;
	g_rmdir (_tmp57_);
	_g_free0 (_tmp57_);
	_tmp59_ = subsystem;
	if (g_strcmp0 (_tmp59_, "usb") == 0) {
		_tmp58_ = TRUE;
	} else {
		const gchar* _tmp60_;
		_tmp60_ = subsystem;
		_tmp58_ = g_strcmp0 (_tmp60_, "pci") == 0;
	}
	_tmp61_ = _tmp58_;
	if (_tmp61_) {
		const gchar* _tmp62_;
		const gchar* _tmp63_;
		const gchar* _tmp64_;
		gchar* _tmp65_ = NULL;
		gchar* _tmp66_;
		const gchar* _tmp67_;
		const gchar* _tmp68_;
		gchar* _tmp69_ = NULL;
		gchar* _tmp70_;
		const gchar* _tmp71_;
		const gchar* _tmp72_;
		gchar* _tmp73_ = NULL;
		gchar* _tmp74_;
		_tmp62_ = self->priv->sys_dir;
		_tmp63_ = subsystem;
		_tmp64_ = devname;
		_tmp65_ = g_build_filename (_tmp62_, "bus", _tmp63_, "devices", _tmp64_, NULL);
		_tmp66_ = _tmp65_;
		g_unlink (_tmp66_);
		_g_free0 (_tmp66_);
		_tmp67_ = self->priv->sys_dir;
		_tmp68_ = subsystem;
		_tmp69_ = g_build_filename (_tmp67_, "bus", _tmp68_, "devices", NULL);
		_tmp70_ = _tmp69_;
		g_rmdir (_tmp70_);
		_g_free0 (_tmp70_);
		_tmp71_ = self->priv->sys_dir;
		_tmp72_ = subsystem;
		_tmp73_ = g_build_filename (_tmp71_, "bus", _tmp72_, NULL);
		_tmp74_ = _tmp73_;
		g_rmdir (_tmp74_);
		_g_free0 (_tmp74_);
	}
	_tmp75_ = real_path;
	umockdev_remove_dir (_tmp75_, TRUE);
	_g_free0 (subsystem);
	_g_free0 (devname);
	_g_free0 (real_path);
}


/**
     * umockdev_testbed_add_from_string:
     * @self: A #UMockdevTestbed.
     * @data: Description of the device(s) as generated with umockdev-record
     * @error: return location for a GError, or %NULL
     *
     * Add a set of devices to the testbed from a textual description. This reads
     * the format generated by the umockdev-record tool.
     *
     * Each paragraph defines one device. A line starts with a type tag (like 'E'),
     * followed by a colon, followed by either a value or a "key=value" assignment,
     * depending on the type tag. A device description must start with a 'P:' line.
     * Available type tags are:
     * <itemizedlist>
     *   <listitem><type>P:</type> <emphasis>path</emphasis>: device path in sysfs, starting with
     *             <filename>/devices/</filename>; must occur exactly once at the
     *             start of device definition</listitem>
     *   <listitem><type>E:</type> <emphasis>key=value</emphasis>: udev property
     *             </listitem>
     *   <listitem><type>A:</type> <emphasis>key=value</emphasis>: ASCII sysfs
     *             attribute, with backslash-style escaping of \ (\\) and newlines
     *             (\n)</listitem>
     *   <listitem><type>H:</type> <emphasis>key=value</emphasis>: binary sysfs
     *             attribute, with the value being written as continuous hex string
     *             (e. g. 0081FE0A..)</listitem>
     *   <listitem><type>N:</type> <emphasis>devname</emphasis>[=<emphasis>contents</emphasis>]:
     *             device node name (without the <filename>/dev/</filename>
     *             prefix); if <emphasis>contents</emphasis> is given (encoded in a
     *             continuous hex string), it creates a
     *             <filename>/dev/devname</filename> in the mock environment with
     *             the given contents, otherwise the created dev file will be a
     *             pty; see #umockdev_testbed_get_dev_fd for details.</listitem>
     *   <listitem><type>S:</type> <emphasis>linkname</emphasis>: device node
     *             symlink (without the <filename>/dev/</filename> prefix); ignored right
     *             now.</listitem>
     * </itemizedlist>
     *
     * Returns: %TRUE on success, %FALSE if the data is invalid and an error
     *          occurred.
     */
static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_;
	gchar _tmp1_;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


gboolean umockdev_testbed_add_from_string (UMockdevTestbed* self, const gchar* data, GError** error) {
	gboolean result = FALSE;
	const gchar* _tmp11_;
	gchar* _tmp12_;
	gchar* cur_data;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (data != NULL, FALSE);
	{
		GRegex* _tmp0_;
		GRegex* _tmp3_;
		GRegex* _tmp6_;
		_tmp0_ = self->priv->re_record_val;
		if (_tmp0_ == NULL) {
			GRegex* _tmp1_;
			GRegex* _tmp2_;
			_tmp1_ = g_regex_new ("^([PS]): (.*)(?>\n|$)", 0, 0, &_inner_error_);
			_tmp2_ = _tmp1_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_REGEX_ERROR) {
					goto __catch6_g_regex_error;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
			_g_regex_unref0 (self->priv->re_record_val);
			self->priv->re_record_val = _tmp2_;
		}
		_tmp3_ = self->priv->re_record_keyval;
		if (_tmp3_ == NULL) {
			GRegex* _tmp4_;
			GRegex* _tmp5_;
			_tmp4_ = g_regex_new ("^([EAHL]): ([^=\n]+)=(.*)(?>\n|$)", 0, 0, &_inner_error_);
			_tmp5_ = _tmp4_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_REGEX_ERROR) {
					goto __catch6_g_regex_error;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
			_g_regex_unref0 (self->priv->re_record_keyval);
			self->priv->re_record_keyval = _tmp5_;
		}
		_tmp6_ = self->priv->re_record_optval;
		if (_tmp6_ == NULL) {
			GRegex* _tmp7_;
			GRegex* _tmp8_;
			_tmp7_ = g_regex_new ("^([N]): ([^=\n]+)(?>=([0-9A-F]+))?(?>\n|$)", 0, 0, &_inner_error_);
			_tmp8_ = _tmp7_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_REGEX_ERROR) {
					goto __catch6_g_regex_error;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
			_g_regex_unref0 (self->priv->re_record_optval);
			self->priv->re_record_optval = _tmp8_;
		}
	}
	goto __finally6;
	__catch6_g_regex_error:
	{
		GError* e = NULL;
		FILE* _tmp9_;
		const gchar* _tmp10_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp9_ = stderr;
		_tmp10_ = e->message;
		fprintf (_tmp9_, "Internal error, cannot create regex: %s\n", _tmp10_);
		abort ();
		_g_error_free0 (e);
	}
	__finally6:
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == UMOCKDEV_ERROR) {
			g_propagate_error (error, _inner_error_);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	_tmp11_ = data;
	_tmp12_ = g_strdup (_tmp11_);
	cur_data = _tmp12_;
	while (TRUE) {
		const gchar* _tmp13_;
		gchar _tmp14_ = '\0';
		const gchar* _tmp15_;
		gchar* _tmp16_ = NULL;
		gchar* _tmp17_;
		_tmp13_ = cur_data;
		_tmp14_ = string_get (_tmp13_, (glong) 0);
		if (!(_tmp14_ != '\0')) {
			break;
		}
		_tmp15_ = cur_data;
		_tmp16_ = umockdev_testbed_add_dev_from_string (self, _tmp15_, &_inner_error_);
		_tmp17_ = _tmp16_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == UMOCKDEV_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (cur_data);
				return FALSE;
			} else {
				_g_free0 (cur_data);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
		}
		_g_free0 (cur_data);
		cur_data = _tmp17_;
	}
	result = TRUE;
	_g_free0 (cur_data);
	return result;
}


/**
     * umockdev_testbed_add_from_file:
     * @self: A #UMockdevTestbed.
     * @path: Path to file with description of the device(s) as generated with umockdev-record
     * @error: return location for a GError, or %NULL
     *
     * Add a set of devices to the testbed from a textual description. This
     * reads a file with the format generated by the umockdev-record tool, and
     * is mostly a convenience wrapper around
     * @umockdev_testbed_add_from_string.
     *
     * Returns: %TRUE on success, %FALSE if the @path cannot be read or thhe
     *          data is invalid and an error occurred.
     */
gboolean umockdev_testbed_add_from_file (UMockdevTestbed* self, const gchar* path, GError** error) {
	gboolean result = FALSE;
	gchar* contents = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (path != NULL, FALSE);
	_tmp0_ = path;
	g_file_get_contents (_tmp0_, &_tmp1_, NULL, &_inner_error_);
	_g_free0 (contents);
	contents = _tmp1_;
	if (_inner_error_ != NULL) {
		if ((_inner_error_->domain == UMOCKDEV_ERROR) || (_inner_error_->domain == G_FILE_ERROR)) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (contents);
			return FALSE;
		} else {
			_g_free0 (contents);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	_tmp2_ = contents;
	_tmp3_ = umockdev_testbed_add_from_string (self, _tmp2_, &_inner_error_);
	_tmp4_ = _tmp3_;
	if (_inner_error_ != NULL) {
		if ((_inner_error_->domain == UMOCKDEV_ERROR) || (_inner_error_->domain == G_FILE_ERROR)) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (contents);
			return FALSE;
		} else {
			_g_free0 (contents);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	result = _tmp4_;
	_g_free0 (contents);
	return result;
}


/**
     * umockdev_testbed_uevent:
     * @self: A #UMockdevTestbed.
     * @devpath: The full device path, as returned by #umockdev_testbed_add_device()
     * @action: "add", "remove", or "change"
     *
     * Generate an uevent for a device.
     */
void umockdev_testbed_uevent (UMockdevTestbed* self, const gchar* devpath, const gchar* action) {
	uevent_sender* _tmp0_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	uevent_sender* _tmp6_;
	const gchar* _tmp7_;
	const gchar* _tmp8_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (devpath != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = self->priv->ev_sender;
	if (_tmp0_ == NULL) {
		const gchar* _tmp1_;
		uevent_sender* _tmp2_;
		uevent_sender* _tmp3_;
		g_debug ("umockdev.vala:622: umockdev_testbed_uevent: lazily initializing uevent" \
"_sender");
		_tmp1_ = self->priv->root_dir;
		_tmp2_ = uevent_sender_open (_tmp1_);
		_uevent_sender_close0 (self->priv->ev_sender);
		self->priv->ev_sender = _tmp2_;
		_tmp3_ = self->priv->ev_sender;
		_vala_assert (_tmp3_ != NULL, "this.ev_sender != null");
	}
	_tmp4_ = action;
	_tmp5_ = devpath;
	g_debug ("umockdev.vala:626: umockdev_testbed_uevent: sending uevent %s for devi" \
"ce %s", _tmp4_, _tmp5_);
	_tmp6_ = self->priv->ev_sender;
	_tmp7_ = devpath;
	_tmp8_ = action;
	uevent_sender_send (_tmp6_, _tmp7_, _tmp8_);
}


/**
     * umockdev_testbed_load_ioctl:
     * @self: A #UMockdevTestbed.
     * @dev: Device path (/dev/...) for which to load the ioctl record.
     * @recordfile: Path of the ioctl record file.
     * @error: return location for a GError, or %NULL
     *
     * Load an ioctl record file for a particular device into the testbed.
     * ioctl records can be created with umockdev-record --ioctl.
     * They can optionally be xz compressed to save space (but then are
     * required to have an .xz file name suffix).
     *
     * Returns: %TRUE on success, %FALSE if the data is invalid and an error
     *          occurred.
     */
gboolean umockdev_testbed_load_ioctl (UMockdevTestbed* self, const gchar* dev, const gchar* recordfile, GError** error) {
	gboolean result = FALSE;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* dest;
	gchar* contents = NULL;
	const gchar* _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	gint _tmp6_ = 0;
	const gchar* _tmp7_;
	gboolean _tmp8_ = FALSE;
	const gchar* _tmp24_;
	const gchar* _tmp25_;
	gboolean _tmp26_ = FALSE;
	gboolean _tmp27_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (dev != NULL, FALSE);
	g_return_val_if_fail (recordfile != NULL, FALSE);
	_tmp0_ = self->priv->root_dir;
	_tmp1_ = dev;
	_tmp2_ = g_build_filename (_tmp0_, "ioctl", _tmp1_, NULL);
	dest = _tmp2_;
	_tmp3_ = dest;
	_tmp4_ = g_path_get_dirname (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_mkdir_with_parents (_tmp5_, 0755);
	_vala_assert (_tmp6_ == 0, "DirUtils.create_with_parents(Path.get_dirname(dest), 0755) == 0");
	_g_free0 (_tmp5_);
	_tmp7_ = recordfile;
	_tmp8_ = g_str_has_suffix (_tmp7_, ".xz");
	if (_tmp8_) {
		{
			gint exit = 0;
			gchar* _tmp9_;
			gchar* _tmp10_;
			const gchar* _tmp11_;
			gchar* _tmp12_;
			gchar** _tmp13_ = NULL;
			gchar** _tmp14_;
			gint _tmp14__length1;
			gchar* _tmp15_ = NULL;
			gint _tmp16_ = 0;
			gint _tmp17_;
			_tmp9_ = g_strdup ("xz");
			_tmp10_ = g_strdup ("-cd");
			_tmp11_ = recordfile;
			_tmp12_ = g_strdup (_tmp11_);
			_tmp13_ = g_new0 (gchar*, 3 + 1);
			_tmp13_[0] = _tmp9_;
			_tmp13_[1] = _tmp10_;
			_tmp13_[2] = _tmp12_;
			_tmp14_ = _tmp13_;
			_tmp14__length1 = 3;
			g_spawn_sync (NULL, _tmp14_, NULL, G_SPAWN_SEARCH_PATH, NULL, NULL, &_tmp15_, NULL, &_tmp16_, &_inner_error_);
			_g_free0 (contents);
			contents = _tmp15_;
			exit = _tmp16_;
			_tmp14_ = (_vala_array_free (_tmp14_, _tmp14__length1, (GDestroyNotify) g_free), NULL);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_SPAWN_ERROR) {
					goto __catch7_g_spawn_error;
				}
				_g_free0 (contents);
				_g_free0 (dest);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
			_tmp17_ = exit;
			_vala_assert (_tmp17_ == 0, "exit == 0");
		}
		goto __finally7;
		__catch7_g_spawn_error:
		{
			GError* e = NULL;
			const gchar* _tmp18_;
			const gchar* _tmp19_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp18_ = recordfile;
			_tmp19_ = e->message;
			g_error ("umockdev.vala:663: Cannot call xz to decompress %s: %s", _tmp18_, _tmp19_);
			_g_error_free0 (e);
		}
		__finally7:
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_FILE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (contents);
				_g_free0 (dest);
				return FALSE;
			} else {
				_g_free0 (contents);
				_g_free0 (dest);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
		}
	} else {
		const gchar* _tmp20_;
		gchar* _tmp21_ = NULL;
		gboolean _tmp22_ = FALSE;
		gboolean _tmp23_;
		_tmp20_ = recordfile;
		_tmp22_ = g_file_get_contents (_tmp20_, &_tmp21_, NULL, &_inner_error_);
		_g_free0 (contents);
		contents = _tmp21_;
		_tmp23_ = _tmp22_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_FILE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (contents);
				_g_free0 (dest);
				return FALSE;
			} else {
				_g_free0 (contents);
				_g_free0 (dest);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
		}
		_vala_assert (_tmp23_, "FileUtils.get_contents(recordfile, out contents)");
	}
	_tmp24_ = dest;
	_tmp25_ = contents;
	_tmp26_ = g_file_set_contents (_tmp24_, _tmp25_, (gssize) (-1), &_inner_error_);
	_tmp27_ = _tmp26_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_FILE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (contents);
			_g_free0 (dest);
			return FALSE;
		} else {
			_g_free0 (contents);
			_g_free0 (dest);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	result = _tmp27_;
	_g_free0 (contents);
	_g_free0 (dest);
	return result;
}


/**
     * umockdev_testbed_load_script:
     * @self: A #UMockdevTestbed.
     * @dev: Device path (/dev/...) for which to load the script record.
     * @recordfile: Path of the script record file.
     * @error: return location for a GError, or %NULL
     *
     * Load a script record file for a particular device into the testbed.
     * script records can be created with umockdev-record --script.
     *
     * Returns: %TRUE on success, %FALSE if @recordfile is invalid and an error
     *          occurred.
     */
gboolean umockdev_testbed_load_script (UMockdevTestbed* self, const gchar* dev, const gchar* recordfile, GError** error) {
	gboolean result = FALSE;
	GHashTable* _tmp0_;
	const gchar* _tmp1_;
	gboolean _tmp2_ = FALSE;
	const gchar* _tmp3_;
	gint _tmp4_ = 0;
	gint fd;
	gint _tmp5_;
	const gchar* _tmp11_;
	const gchar* _tmp12_;
	gint _tmp13_;
	UMockdevScriptRunner* _tmp14_;
	UMockdevScriptRunner* _tmp15_;
	GHashTable* _tmp16_;
	const gchar* _tmp17_;
	gchar* _tmp18_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (dev != NULL, FALSE);
	g_return_val_if_fail (recordfile != NULL, FALSE);
	_tmp0_ = self->priv->dev_script_runner;
	_tmp1_ = dev;
	_tmp2_ = g_hash_table_contains (_tmp0_, _tmp1_);
	_vala_assert (!_tmp2_, "!this.dev_script_runner.contains (dev)");
	_tmp3_ = dev;
	_tmp4_ = umockdev_testbed_get_dev_fd (self, _tmp3_);
	fd = _tmp4_;
	_tmp5_ = fd;
	if (_tmp5_ < 0) {
		const gchar* _tmp6_;
		gchar* _tmp7_;
		gchar* _tmp8_;
		GError* _tmp9_;
		GError* _tmp10_;
		_tmp6_ = dev;
		_tmp7_ = g_strconcat (_tmp6_, " is not a device suitable for scripts", NULL);
		_tmp8_ = _tmp7_;
		_tmp9_ = g_error_new_literal (G_FILE_ERROR, G_FILE_ERROR_INVAL, _tmp8_);
		_tmp10_ = _tmp9_;
		_g_free0 (_tmp8_);
		_inner_error_ = _tmp10_;
		if (_inner_error_->domain == G_FILE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	_tmp11_ = dev;
	_tmp12_ = recordfile;
	_tmp13_ = fd;
	_tmp14_ = umockdev_script_runner_new (_tmp11_, _tmp12_, _tmp13_, &_inner_error_);
	_tmp15_ = _tmp14_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_FILE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	_tmp16_ = self->priv->dev_script_runner;
	_tmp17_ = dev;
	_tmp18_ = g_strdup (_tmp17_);
	g_hash_table_insert (_tmp16_, _tmp18_, _tmp15_);
	result = TRUE;
	return result;
}


static void _vala_array_add3 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add4 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add5 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add6 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add7 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add8 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add9 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add10 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static gchar* umockdev_testbed_add_dev_from_string (UMockdevTestbed* self, const gchar* data, GError** error) {
	gchar* result = NULL;
	gchar type = '\0';
	gchar* key = NULL;
	gchar* val = NULL;
	gchar* devpath;
	gchar* subsystem;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* cur_data;
	gchar* devnode_path;
	guint8* _tmp2_ = NULL;
	guint8* devnode_contents;
	gint devnode_contents_length1;
	gint _devnode_contents_size_;
	const gchar* _tmp3_;
	gchar _tmp4_ = '\0';
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gboolean _tmp8_ = FALSE;
	const gchar* _tmp9_;
	gboolean _tmp11_;
	const gchar* _tmp13_;
	gboolean _tmp14_ = FALSE;
	const gchar* _tmp17_;
	gchar** _tmp18_ = NULL;
	gchar** attrs;
	gint attrs_length1;
	gint _attrs_size_;
	gchar** _tmp19_ = NULL;
	gchar** binattrs;
	gint binattrs_length1;
	gint _binattrs_size_;
	gchar** _tmp20_ = NULL;
	gchar** linkattrs;
	gint linkattrs_length1;
	gint _linkattrs_size_;
	gchar** _tmp21_ = NULL;
	gchar** props;
	gint props_length1;
	gint _props_size_;
	const gchar* _tmp80_;
	const gchar* _tmp83_;
	const gchar* _tmp84_;
	const gchar* _tmp85_;
	const gchar* _tmp86_;
	gchar* _tmp87_ = NULL;
	gchar* _tmp88_;
	gchar** _tmp89_;
	gint _tmp89__length1;
	gchar** _tmp90_;
	gint _tmp90__length1;
	gchar* _tmp91_ = NULL;
	gchar* _tmp92_;
	gchar* syspath;
	const gchar* _tmp121_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (data != NULL, NULL);
	devpath = NULL;
	subsystem = NULL;
	_tmp0_ = data;
	_tmp1_ = g_strdup (_tmp0_);
	cur_data = _tmp1_;
	devnode_path = NULL;
	_tmp2_ = g_new0 (guint8, 0);
	devnode_contents = _tmp2_;
	devnode_contents_length1 = 0;
	_devnode_contents_size_ = devnode_contents_length1;
	_tmp3_ = cur_data;
	_tmp7_ = umockdev_testbed_record_parse_line (self, _tmp3_, &_tmp4_, &_tmp5_, &_tmp6_);
	type = _tmp4_;
	_g_free0 (key);
	key = _tmp5_;
	_g_free0 (devpath);
	devpath = _tmp6_;
	_g_free0 (cur_data);
	cur_data = _tmp7_;
	_tmp9_ = cur_data;
	if (_tmp9_ == NULL) {
		_tmp8_ = TRUE;
	} else {
		gchar _tmp10_;
		_tmp10_ = type;
		_tmp8_ = _tmp10_ != 'P';
	}
	_tmp11_ = _tmp8_;
	if (_tmp11_) {
		GError* _tmp12_;
		_tmp12_ = g_error_new_literal (UMOCKDEV_ERROR, UMOCKDEV_ERROR_PARSE, "device descriptions must start with a \"P: /devices/path/...\" line");
		_inner_error_ = _tmp12_;
		if (_inner_error_->domain == UMOCKDEV_ERROR) {
			g_propagate_error (error, _inner_error_);
			devnode_contents = (g_free (devnode_contents), NULL);
			_g_free0 (devnode_path);
			_g_free0 (cur_data);
			_g_free0 (subsystem);
			_g_free0 (devpath);
			_g_free0 (val);
			_g_free0 (key);
			return NULL;
		} else {
			devnode_contents = (g_free (devnode_contents), NULL);
			_g_free0 (devnode_path);
			_g_free0 (cur_data);
			_g_free0 (subsystem);
			_g_free0 (devpath);
			_g_free0 (val);
			_g_free0 (key);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp13_ = devpath;
	_tmp14_ = g_str_has_prefix (_tmp13_, "/devices/");
	if (!_tmp14_) {
		const gchar* _tmp15_;
		GError* _tmp16_;
		_tmp15_ = devpath;
		_tmp16_ = g_error_new (UMOCKDEV_ERROR, UMOCKDEV_ERROR_VALUE, "invalid device path '%s': must start with /devices/", _tmp15_);
		_inner_error_ = _tmp16_;
		if (_inner_error_->domain == UMOCKDEV_ERROR) {
			g_propagate_error (error, _inner_error_);
			devnode_contents = (g_free (devnode_contents), NULL);
			_g_free0 (devnode_path);
			_g_free0 (cur_data);
			_g_free0 (subsystem);
			_g_free0 (devpath);
			_g_free0 (val);
			_g_free0 (key);
			return NULL;
		} else {
			devnode_contents = (g_free (devnode_contents), NULL);
			_g_free0 (devnode_path);
			_g_free0 (cur_data);
			_g_free0 (subsystem);
			_g_free0 (devpath);
			_g_free0 (val);
			_g_free0 (key);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp17_ = devpath;
	g_debug ("umockdev.vala:714: parsing device description for %s", _tmp17_);
	_tmp18_ = g_new0 (gchar*, 0 + 1);
	attrs = _tmp18_;
	attrs_length1 = 0;
	_attrs_size_ = attrs_length1;
	_tmp19_ = g_new0 (gchar*, 0 + 1);
	binattrs = _tmp19_;
	binattrs_length1 = 0;
	_binattrs_size_ = binattrs_length1;
	_tmp20_ = g_new0 (gchar*, 0 + 1);
	linkattrs = _tmp20_;
	linkattrs_length1 = 0;
	_linkattrs_size_ = linkattrs_length1;
	_tmp21_ = g_new0 (gchar*, 0 + 1);
	props = _tmp21_;
	props_length1 = 0;
	_props_size_ = props_length1;
	while (TRUE) {
		gboolean _tmp22_ = FALSE;
		const gchar* _tmp23_;
		gint _tmp24_;
		gint _tmp25_;
		gboolean _tmp28_;
		const gchar* _tmp29_;
		gchar _tmp30_ = '\0';
		gchar* _tmp31_ = NULL;
		gchar* _tmp32_ = NULL;
		gchar* _tmp33_ = NULL;
		const gchar* _tmp34_;
		gchar _tmp37_;
		_tmp23_ = cur_data;
		_tmp24_ = strlen (_tmp23_);
		_tmp25_ = _tmp24_;
		if (_tmp25_ > 0) {
			const gchar* _tmp26_;
			gchar _tmp27_ = '\0';
			_tmp26_ = cur_data;
			_tmp27_ = string_get (_tmp26_, (glong) 0);
			_tmp22_ = _tmp27_ != '\n';
		} else {
			_tmp22_ = FALSE;
		}
		_tmp28_ = _tmp22_;
		if (!_tmp28_) {
			break;
		}
		_tmp29_ = cur_data;
		_tmp33_ = umockdev_testbed_record_parse_line (self, _tmp29_, &_tmp30_, &_tmp31_, &_tmp32_);
		type = _tmp30_;
		_g_free0 (key);
		key = _tmp31_;
		_g_free0 (val);
		val = _tmp32_;
		_g_free0 (cur_data);
		cur_data = _tmp33_;
		_tmp34_ = cur_data;
		if (_tmp34_ == NULL) {
			const gchar* _tmp35_;
			GError* _tmp36_;
			_tmp35_ = devpath;
			_tmp36_ = g_error_new (UMOCKDEV_ERROR, UMOCKDEV_ERROR_PARSE, "malformed attribute or property line in description of device %s", _tmp35_);
			_inner_error_ = _tmp36_;
			if (_inner_error_->domain == UMOCKDEV_ERROR) {
				g_propagate_error (error, _inner_error_);
				props = (_vala_array_free (props, props_length1, (GDestroyNotify) g_free), NULL);
				linkattrs = (_vala_array_free (linkattrs, linkattrs_length1, (GDestroyNotify) g_free), NULL);
				binattrs = (_vala_array_free (binattrs, binattrs_length1, (GDestroyNotify) g_free), NULL);
				attrs = (_vala_array_free (attrs, attrs_length1, (GDestroyNotify) g_free), NULL);
				devnode_contents = (g_free (devnode_contents), NULL);
				_g_free0 (devnode_path);
				_g_free0 (cur_data);
				_g_free0 (subsystem);
				_g_free0 (devpath);
				_g_free0 (val);
				_g_free0 (key);
				return NULL;
			} else {
				props = (_vala_array_free (props, props_length1, (GDestroyNotify) g_free), NULL);
				linkattrs = (_vala_array_free (linkattrs, linkattrs_length1, (GDestroyNotify) g_free), NULL);
				binattrs = (_vala_array_free (binattrs, binattrs_length1, (GDestroyNotify) g_free), NULL);
				attrs = (_vala_array_free (attrs, attrs_length1, (GDestroyNotify) g_free), NULL);
				devnode_contents = (g_free (devnode_contents), NULL);
				_g_free0 (devnode_path);
				_g_free0 (cur_data);
				_g_free0 (subsystem);
				_g_free0 (devpath);
				_g_free0 (val);
				_g_free0 (key);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp37_ = type;
		switch (_tmp37_) {
			case 'H':
			{
				gchar** _tmp38_;
				gint _tmp38__length1;
				const gchar* _tmp39_;
				gchar* _tmp40_;
				gchar** _tmp41_;
				gint _tmp41__length1;
				const gchar* _tmp42_;
				gchar* _tmp43_;
				_tmp38_ = binattrs;
				_tmp38__length1 = binattrs_length1;
				_tmp39_ = key;
				_tmp40_ = g_strdup (_tmp39_);
				_vala_array_add3 (&binattrs, &binattrs_length1, &_binattrs_size_, _tmp40_);
				_tmp41_ = binattrs;
				_tmp41__length1 = binattrs_length1;
				_tmp42_ = val;
				_tmp43_ = g_strdup (_tmp42_);
				_vala_array_add4 (&binattrs, &binattrs_length1, &_binattrs_size_, _tmp43_);
				break;
			}
			case 'A':
			{
				gchar** _tmp44_;
				gint _tmp44__length1;
				const gchar* _tmp45_;
				gchar* _tmp46_;
				gchar** _tmp47_;
				gint _tmp47__length1;
				const gchar* _tmp48_;
				gchar* _tmp49_ = NULL;
				_tmp44_ = attrs;
				_tmp44__length1 = attrs_length1;
				_tmp45_ = key;
				_tmp46_ = g_strdup (_tmp45_);
				_vala_array_add5 (&attrs, &attrs_length1, &_attrs_size_, _tmp46_);
				_tmp47_ = attrs;
				_tmp47__length1 = attrs_length1;
				_tmp48_ = val;
				_tmp49_ = g_strcompress (_tmp48_);
				_vala_array_add6 (&attrs, &attrs_length1, &_attrs_size_, _tmp49_);
				break;
			}
			case 'L':
			{
				gchar** _tmp50_;
				gint _tmp50__length1;
				const gchar* _tmp51_;
				gchar* _tmp52_;
				gchar** _tmp53_;
				gint _tmp53__length1;
				const gchar* _tmp54_;
				gchar* _tmp55_;
				_tmp50_ = linkattrs;
				_tmp50__length1 = linkattrs_length1;
				_tmp51_ = key;
				_tmp52_ = g_strdup (_tmp51_);
				_vala_array_add7 (&linkattrs, &linkattrs_length1, &_linkattrs_size_, _tmp52_);
				_tmp53_ = linkattrs;
				_tmp53__length1 = linkattrs_length1;
				_tmp54_ = val;
				_tmp55_ = g_strdup (_tmp54_);
				_vala_array_add8 (&linkattrs, &linkattrs_length1, &_linkattrs_size_, _tmp55_);
				break;
			}
			case 'E':
			{
				gchar** _tmp56_;
				gint _tmp56__length1;
				const gchar* _tmp57_;
				gchar* _tmp58_;
				gchar** _tmp59_;
				gint _tmp59__length1;
				const gchar* _tmp60_;
				gchar* _tmp61_;
				const gchar* _tmp62_;
				_tmp56_ = props;
				_tmp56__length1 = props_length1;
				_tmp57_ = key;
				_tmp58_ = g_strdup (_tmp57_);
				_vala_array_add9 (&props, &props_length1, &_props_size_, _tmp58_);
				_tmp59_ = props;
				_tmp59__length1 = props_length1;
				_tmp60_ = val;
				_tmp61_ = g_strdup (_tmp60_);
				_vala_array_add10 (&props, &props_length1, &_props_size_, _tmp61_);
				_tmp62_ = key;
				if (g_strcmp0 (_tmp62_, "SUBSYSTEM") == 0) {
					const gchar* _tmp63_;
					const gchar* _tmp66_;
					gchar* _tmp67_;
					_tmp63_ = subsystem;
					if (_tmp63_ != NULL) {
						const gchar* _tmp64_;
						GError* _tmp65_;
						_tmp64_ = devpath;
						_tmp65_ = g_error_new (UMOCKDEV_ERROR, UMOCKDEV_ERROR_VALUE, "duplicate SUBSYSTEM property in description of device %s", _tmp64_);
						_inner_error_ = _tmp65_;
						if (_inner_error_->domain == UMOCKDEV_ERROR) {
							g_propagate_error (error, _inner_error_);
							props = (_vala_array_free (props, props_length1, (GDestroyNotify) g_free), NULL);
							linkattrs = (_vala_array_free (linkattrs, linkattrs_length1, (GDestroyNotify) g_free), NULL);
							binattrs = (_vala_array_free (binattrs, binattrs_length1, (GDestroyNotify) g_free), NULL);
							attrs = (_vala_array_free (attrs, attrs_length1, (GDestroyNotify) g_free), NULL);
							devnode_contents = (g_free (devnode_contents), NULL);
							_g_free0 (devnode_path);
							_g_free0 (cur_data);
							_g_free0 (subsystem);
							_g_free0 (devpath);
							_g_free0 (val);
							_g_free0 (key);
							return NULL;
						} else {
							props = (_vala_array_free (props, props_length1, (GDestroyNotify) g_free), NULL);
							linkattrs = (_vala_array_free (linkattrs, linkattrs_length1, (GDestroyNotify) g_free), NULL);
							binattrs = (_vala_array_free (binattrs, binattrs_length1, (GDestroyNotify) g_free), NULL);
							attrs = (_vala_array_free (attrs, attrs_length1, (GDestroyNotify) g_free), NULL);
							devnode_contents = (g_free (devnode_contents), NULL);
							_g_free0 (devnode_path);
							_g_free0 (cur_data);
							_g_free0 (subsystem);
							_g_free0 (devpath);
							_g_free0 (val);
							_g_free0 (key);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					_tmp66_ = val;
					_tmp67_ = g_strdup (_tmp66_);
					_g_free0 (subsystem);
					subsystem = _tmp67_;
				}
				break;
			}
			case 'P':
			{
				const gchar* _tmp68_;
				GError* _tmp69_;
				_tmp68_ = devpath;
				_tmp69_ = g_error_new (UMOCKDEV_ERROR, UMOCKDEV_ERROR_PARSE, "invalid P: line in description of device %s", _tmp68_);
				_inner_error_ = _tmp69_;
				if (_inner_error_->domain == UMOCKDEV_ERROR) {
					g_propagate_error (error, _inner_error_);
					props = (_vala_array_free (props, props_length1, (GDestroyNotify) g_free), NULL);
					linkattrs = (_vala_array_free (linkattrs, linkattrs_length1, (GDestroyNotify) g_free), NULL);
					binattrs = (_vala_array_free (binattrs, binattrs_length1, (GDestroyNotify) g_free), NULL);
					attrs = (_vala_array_free (attrs, attrs_length1, (GDestroyNotify) g_free), NULL);
					devnode_contents = (g_free (devnode_contents), NULL);
					_g_free0 (devnode_path);
					_g_free0 (cur_data);
					_g_free0 (subsystem);
					_g_free0 (devpath);
					_g_free0 (val);
					_g_free0 (key);
					return NULL;
				} else {
					props = (_vala_array_free (props, props_length1, (GDestroyNotify) g_free), NULL);
					linkattrs = (_vala_array_free (linkattrs, linkattrs_length1, (GDestroyNotify) g_free), NULL);
					binattrs = (_vala_array_free (binattrs, binattrs_length1, (GDestroyNotify) g_free), NULL);
					attrs = (_vala_array_free (attrs, attrs_length1, (GDestroyNotify) g_free), NULL);
					devnode_contents = (g_free (devnode_contents), NULL);
					_g_free0 (devnode_path);
					_g_free0 (cur_data);
					_g_free0 (subsystem);
					_g_free0 (devpath);
					_g_free0 (val);
					_g_free0 (key);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			case 'N':
			{
				const gchar* _tmp70_;
				const gchar* _tmp71_;
				gchar* _tmp72_ = NULL;
				const gchar* _tmp73_;
				_tmp70_ = self->priv->root_dir;
				_tmp71_ = key;
				_tmp72_ = g_build_filename (_tmp70_, "dev", _tmp71_, NULL);
				_g_free0 (devnode_path);
				devnode_path = _tmp72_;
				_tmp73_ = val;
				if (_tmp73_ != NULL) {
					const gchar* _tmp74_;
					gint _tmp75_ = 0;
					guint8* _tmp76_ = NULL;
					guint8* _tmp77_;
					gint _tmp77__length1;
					gint __tmp77__size_;
					_tmp74_ = val;
					_tmp76_ = umockdev_decode_hex (_tmp74_, &_tmp75_, &_inner_error_);
					_tmp77_ = _tmp76_;
					_tmp77__length1 = _tmp75_;
					__tmp77__size_ = _tmp77__length1;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == UMOCKDEV_ERROR) {
							g_propagate_error (error, _inner_error_);
							props = (_vala_array_free (props, props_length1, (GDestroyNotify) g_free), NULL);
							linkattrs = (_vala_array_free (linkattrs, linkattrs_length1, (GDestroyNotify) g_free), NULL);
							binattrs = (_vala_array_free (binattrs, binattrs_length1, (GDestroyNotify) g_free), NULL);
							attrs = (_vala_array_free (attrs, attrs_length1, (GDestroyNotify) g_free), NULL);
							devnode_contents = (g_free (devnode_contents), NULL);
							_g_free0 (devnode_path);
							_g_free0 (cur_data);
							_g_free0 (subsystem);
							_g_free0 (devpath);
							_g_free0 (val);
							_g_free0 (key);
							return NULL;
						} else {
							props = (_vala_array_free (props, props_length1, (GDestroyNotify) g_free), NULL);
							linkattrs = (_vala_array_free (linkattrs, linkattrs_length1, (GDestroyNotify) g_free), NULL);
							binattrs = (_vala_array_free (binattrs, binattrs_length1, (GDestroyNotify) g_free), NULL);
							attrs = (_vala_array_free (attrs, attrs_length1, (GDestroyNotify) g_free), NULL);
							devnode_contents = (g_free (devnode_contents), NULL);
							_g_free0 (devnode_path);
							_g_free0 (cur_data);
							_g_free0 (subsystem);
							_g_free0 (devpath);
							_g_free0 (val);
							_g_free0 (key);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					devnode_contents = (g_free (devnode_contents), NULL);
					devnode_contents = _tmp77_;
					devnode_contents_length1 = _tmp77__length1;
					_devnode_contents_size_ = devnode_contents_length1;
				}
				break;
			}
			case 'S':
			{
				break;
			}
			default:
			{
				gchar _tmp78_;
				GError* _tmp79_;
				_tmp78_ = type;
				_tmp79_ = g_error_new (UMOCKDEV_ERROR, UMOCKDEV_ERROR_PARSE, "Unknown line type '%c'\n", _tmp78_);
				_inner_error_ = _tmp79_;
				if (_inner_error_->domain == UMOCKDEV_ERROR) {
					g_propagate_error (error, _inner_error_);
					props = (_vala_array_free (props, props_length1, (GDestroyNotify) g_free), NULL);
					linkattrs = (_vala_array_free (linkattrs, linkattrs_length1, (GDestroyNotify) g_free), NULL);
					binattrs = (_vala_array_free (binattrs, binattrs_length1, (GDestroyNotify) g_free), NULL);
					attrs = (_vala_array_free (attrs, attrs_length1, (GDestroyNotify) g_free), NULL);
					devnode_contents = (g_free (devnode_contents), NULL);
					_g_free0 (devnode_path);
					_g_free0 (cur_data);
					_g_free0 (subsystem);
					_g_free0 (devpath);
					_g_free0 (val);
					_g_free0 (key);
					return NULL;
				} else {
					props = (_vala_array_free (props, props_length1, (GDestroyNotify) g_free), NULL);
					linkattrs = (_vala_array_free (linkattrs, linkattrs_length1, (GDestroyNotify) g_free), NULL);
					binattrs = (_vala_array_free (binattrs, binattrs_length1, (GDestroyNotify) g_free), NULL);
					attrs = (_vala_array_free (attrs, attrs_length1, (GDestroyNotify) g_free), NULL);
					devnode_contents = (g_free (devnode_contents), NULL);
					_g_free0 (devnode_path);
					_g_free0 (cur_data);
					_g_free0 (subsystem);
					_g_free0 (devpath);
					_g_free0 (val);
					_g_free0 (key);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		}
	}
	_tmp80_ = subsystem;
	if (_tmp80_ == NULL) {
		const gchar* _tmp81_;
		GError* _tmp82_;
		_tmp81_ = devpath;
		_tmp82_ = g_error_new (UMOCKDEV_ERROR, UMOCKDEV_ERROR_VALUE, "missing SUBSYSTEM property in description of device %s", _tmp81_);
		_inner_error_ = _tmp82_;
		if (_inner_error_->domain == UMOCKDEV_ERROR) {
			g_propagate_error (error, _inner_error_);
			props = (_vala_array_free (props, props_length1, (GDestroyNotify) g_free), NULL);
			linkattrs = (_vala_array_free (linkattrs, linkattrs_length1, (GDestroyNotify) g_free), NULL);
			binattrs = (_vala_array_free (binattrs, binattrs_length1, (GDestroyNotify) g_free), NULL);
			attrs = (_vala_array_free (attrs, attrs_length1, (GDestroyNotify) g_free), NULL);
			devnode_contents = (g_free (devnode_contents), NULL);
			_g_free0 (devnode_path);
			_g_free0 (cur_data);
			_g_free0 (subsystem);
			_g_free0 (devpath);
			_g_free0 (val);
			_g_free0 (key);
			return NULL;
		} else {
			props = (_vala_array_free (props, props_length1, (GDestroyNotify) g_free), NULL);
			linkattrs = (_vala_array_free (linkattrs, linkattrs_length1, (GDestroyNotify) g_free), NULL);
			binattrs = (_vala_array_free (binattrs, binattrs_length1, (GDestroyNotify) g_free), NULL);
			attrs = (_vala_array_free (attrs, attrs_length1, (GDestroyNotify) g_free), NULL);
			devnode_contents = (g_free (devnode_contents), NULL);
			_g_free0 (devnode_path);
			_g_free0 (cur_data);
			_g_free0 (subsystem);
			_g_free0 (devpath);
			_g_free0 (val);
			_g_free0 (key);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp83_ = devpath;
	_tmp84_ = subsystem;
	g_debug ("umockdev.vala:777: creating device %s (subsystem %s)", _tmp83_, _tmp84_);
	_tmp85_ = subsystem;
	_tmp86_ = devpath;
	_tmp87_ = string_substring (_tmp86_, (glong) 9, (glong) (-1));
	_tmp88_ = _tmp87_;
	_tmp89_ = attrs;
	_tmp89__length1 = attrs_length1;
	_tmp90_ = props;
	_tmp90__length1 = props_length1;
	_tmp91_ = umockdev_testbed_add_devicev (self, _tmp85_, _tmp88_, NULL, _tmp89_, _tmp90_);
	_tmp92_ = _tmp91_;
	_g_free0 (_tmp88_);
	syspath = _tmp92_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp93_;
			_tmp93_ = TRUE;
			while (TRUE) {
				gboolean _tmp94_;
				gint _tmp96_;
				gchar** _tmp97_;
				gint _tmp97__length1;
				gchar** _tmp98_;
				gint _tmp98__length1;
				gint _tmp99_;
				const gchar* _tmp100_;
				gint _tmp101_ = 0;
				guint8* _tmp102_ = NULL;
				guint8* _tmp103_;
				gint _tmp103__length1;
				gint __tmp103__size_;
				const gchar* _tmp104_;
				gchar** _tmp105_;
				gint _tmp105__length1;
				gint _tmp106_;
				const gchar* _tmp107_;
				guint8* _tmp108_;
				gint _tmp108__length1;
				_tmp94_ = _tmp93_;
				if (!_tmp94_) {
					gint _tmp95_;
					_tmp95_ = i;
					i = _tmp95_ + 2;
				}
				_tmp93_ = FALSE;
				_tmp96_ = i;
				_tmp97_ = binattrs;
				_tmp97__length1 = binattrs_length1;
				if (!(_tmp96_ < _tmp97__length1)) {
					break;
				}
				_tmp98_ = binattrs;
				_tmp98__length1 = binattrs_length1;
				_tmp99_ = i;
				_tmp100_ = _tmp98_[_tmp99_ + 1];
				_tmp102_ = umockdev_decode_hex (_tmp100_, &_tmp101_, &_inner_error_);
				_tmp103_ = _tmp102_;
				_tmp103__length1 = _tmp101_;
				__tmp103__size_ = _tmp103__length1;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == UMOCKDEV_ERROR) {
						g_propagate_error (error, _inner_error_);
						_g_free0 (syspath);
						props = (_vala_array_free (props, props_length1, (GDestroyNotify) g_free), NULL);
						linkattrs = (_vala_array_free (linkattrs, linkattrs_length1, (GDestroyNotify) g_free), NULL);
						binattrs = (_vala_array_free (binattrs, binattrs_length1, (GDestroyNotify) g_free), NULL);
						attrs = (_vala_array_free (attrs, attrs_length1, (GDestroyNotify) g_free), NULL);
						devnode_contents = (g_free (devnode_contents), NULL);
						_g_free0 (devnode_path);
						_g_free0 (cur_data);
						_g_free0 (subsystem);
						_g_free0 (devpath);
						_g_free0 (val);
						_g_free0 (key);
						return NULL;
					} else {
						_g_free0 (syspath);
						props = (_vala_array_free (props, props_length1, (GDestroyNotify) g_free), NULL);
						linkattrs = (_vala_array_free (linkattrs, linkattrs_length1, (GDestroyNotify) g_free), NULL);
						binattrs = (_vala_array_free (binattrs, binattrs_length1, (GDestroyNotify) g_free), NULL);
						attrs = (_vala_array_free (attrs, attrs_length1, (GDestroyNotify) g_free), NULL);
						devnode_contents = (g_free (devnode_contents), NULL);
						_g_free0 (devnode_path);
						_g_free0 (cur_data);
						_g_free0 (subsystem);
						_g_free0 (devpath);
						_g_free0 (val);
						_g_free0 (key);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp104_ = syspath;
				_tmp105_ = binattrs;
				_tmp105__length1 = binattrs_length1;
				_tmp106_ = i;
				_tmp107_ = _tmp105_[_tmp106_];
				_tmp108_ = _tmp103_;
				_tmp108__length1 = _tmp103__length1;
				umockdev_testbed_set_attribute_binary (self, _tmp104_, _tmp107_, _tmp108_, _tmp103__length1);
				_tmp108_ = (g_free (_tmp108_), NULL);
			}
		}
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp109_;
			_tmp109_ = TRUE;
			while (TRUE) {
				gboolean _tmp110_;
				gint _tmp112_;
				gchar** _tmp113_;
				gint _tmp113__length1;
				const gchar* _tmp114_;
				gchar** _tmp115_;
				gint _tmp115__length1;
				gint _tmp116_;
				const gchar* _tmp117_;
				gchar** _tmp118_;
				gint _tmp118__length1;
				gint _tmp119_;
				const gchar* _tmp120_;
				_tmp110_ = _tmp109_;
				if (!_tmp110_) {
					gint _tmp111_;
					_tmp111_ = i;
					i = _tmp111_ + 2;
				}
				_tmp109_ = FALSE;
				_tmp112_ = i;
				_tmp113_ = linkattrs;
				_tmp113__length1 = linkattrs_length1;
				if (!(_tmp112_ < _tmp113__length1)) {
					break;
				}
				_tmp114_ = syspath;
				_tmp115_ = linkattrs;
				_tmp115__length1 = linkattrs_length1;
				_tmp116_ = i;
				_tmp117_ = _tmp115_[_tmp116_];
				_tmp118_ = linkattrs;
				_tmp118__length1 = linkattrs_length1;
				_tmp119_ = i;
				_tmp120_ = _tmp118_[_tmp119_ + 1];
				umockdev_testbed_set_attribute_link (self, _tmp114_, _tmp117_, _tmp120_);
			}
		}
	}
	_tmp121_ = devnode_path;
	if (_tmp121_ != NULL) {
		const gchar* _tmp122_;
		const gchar* _tmp123_;
		guint8* _tmp124_;
		gint _tmp124__length1;
		_tmp122_ = subsystem;
		_tmp123_ = devnode_path;
		_tmp124_ = devnode_contents;
		_tmp124__length1 = devnode_contents_length1;
		umockdev_testbed_create_node_for_device (self, _tmp122_, _tmp123_, _tmp124_, _tmp124__length1, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == UMOCKDEV_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (syspath);
				props = (_vala_array_free (props, props_length1, (GDestroyNotify) g_free), NULL);
				linkattrs = (_vala_array_free (linkattrs, linkattrs_length1, (GDestroyNotify) g_free), NULL);
				binattrs = (_vala_array_free (binattrs, binattrs_length1, (GDestroyNotify) g_free), NULL);
				attrs = (_vala_array_free (attrs, attrs_length1, (GDestroyNotify) g_free), NULL);
				devnode_contents = (g_free (devnode_contents), NULL);
				_g_free0 (devnode_path);
				_g_free0 (cur_data);
				_g_free0 (subsystem);
				_g_free0 (devpath);
				_g_free0 (val);
				_g_free0 (key);
				return NULL;
			} else {
				_g_free0 (syspath);
				props = (_vala_array_free (props, props_length1, (GDestroyNotify) g_free), NULL);
				linkattrs = (_vala_array_free (linkattrs, linkattrs_length1, (GDestroyNotify) g_free), NULL);
				binattrs = (_vala_array_free (binattrs, binattrs_length1, (GDestroyNotify) g_free), NULL);
				attrs = (_vala_array_free (attrs, attrs_length1, (GDestroyNotify) g_free), NULL);
				devnode_contents = (g_free (devnode_contents), NULL);
				_g_free0 (devnode_path);
				_g_free0 (cur_data);
				_g_free0 (subsystem);
				_g_free0 (devpath);
				_g_free0 (val);
				_g_free0 (key);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	while (TRUE) {
		gboolean _tmp125_ = FALSE;
		const gchar* _tmp126_;
		gchar _tmp127_ = '\0';
		gboolean _tmp130_;
		const gchar* _tmp131_;
		const gchar* _tmp132_ = NULL;
		gchar* _tmp133_;
		_tmp126_ = cur_data;
		_tmp127_ = string_get (_tmp126_, (glong) 0);
		if (_tmp127_ != '\0') {
			const gchar* _tmp128_;
			gchar _tmp129_ = '\0';
			_tmp128_ = cur_data;
			_tmp129_ = string_get (_tmp128_, (glong) 0);
			_tmp125_ = _tmp129_ == '\n';
		} else {
			_tmp125_ = FALSE;
		}
		_tmp130_ = _tmp125_;
		if (!_tmp130_) {
			break;
		}
		_tmp131_ = cur_data;
		_tmp132_ = g_utf8_next_char (_tmp131_);
		_tmp133_ = g_strdup (_tmp132_);
		_g_free0 (cur_data);
		cur_data = _tmp133_;
	}
	result = cur_data;
	_g_free0 (syspath);
	props = (_vala_array_free (props, props_length1, (GDestroyNotify) g_free), NULL);
	linkattrs = (_vala_array_free (linkattrs, linkattrs_length1, (GDestroyNotify) g_free), NULL);
	binattrs = (_vala_array_free (binattrs, binattrs_length1, (GDestroyNotify) g_free), NULL);
	attrs = (_vala_array_free (attrs, attrs_length1, (GDestroyNotify) g_free), NULL);
	devnode_contents = (g_free (devnode_contents), NULL);
	_g_free0 (devnode_path);
	_g_free0 (subsystem);
	_g_free0 (devpath);
	_g_free0 (val);
	_g_free0 (key);
	return result;
}


static void umockdev_testbed_create_node_for_device (UMockdevTestbed* self, const gchar* subsystem, const gchar* node_path, guint8* node_contents, int node_contents_length1, GError** error) {
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gint _tmp3_ = 0;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	guint8* _tmp6_;
	gint _tmp6__length1;
	gboolean _tmp8_;
	gboolean _tmp10_;
	gint ptym = 0;
	gint ptys = 0;
	gchar* _tmp18_ = NULL;
	gchar* ptyname_array;
	gint ptyname_array_length1;
	gint _ptyname_array_size_;
	gchar* _tmp19_;
	gint _tmp19__length1;
	gint _tmp20_ = 0;
	gint _tmp21_ = 0;
	gint _tmp22_ = 0;
	gchar* _tmp23_;
	gint _tmp23__length1;
	gchar* _tmp24_;
	gchar* ptyname;
	const gchar* _tmp25_;
	const gchar* _tmp26_;
	gint _tmp27_;
	struct termios ios = {0};
	gint _tmp28_;
	struct termios _tmp29_ = {0};
	gint _tmp30_ = 0;
	tcflag_t _tmp31_;
	tcflag_t _tmp32_;
	tcflag_t _tmp33_;
	gint _tmp34_;
	struct termios _tmp35_;
	gint _tmp36_ = 0;
	const gchar* _tmp37_;
	const gchar* _tmp38_;
	gint _tmp39_ = 0;
	const gchar* _tmp40_;
	const gchar* _tmp41_;
	gint _tmp42_;
	gint _tmp43_;
	gchar* _tmp44_ = NULL;
	gchar* devname;
	GHashTable* _tmp45_;
	const gchar* _tmp46_;
	gboolean _tmp47_ = FALSE;
	GHashTable* _tmp48_;
	const gchar* _tmp49_;
	gchar* _tmp50_;
	gint _tmp51_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (subsystem != NULL);
	g_return_if_fail (node_path != NULL);
	_tmp0_ = node_path;
	_tmp1_ = g_path_get_dirname (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_mkdir_with_parents (_tmp2_, 0755);
	_vala_assert (_tmp3_ == 0, "DirUtils.create_with_parents(Path.get_dirname(node_path), 0755) == 0");
	_g_free0 (_tmp2_);
	_tmp6_ = node_contents;
	_tmp6__length1 = node_contents_length1;
	if (_tmp6__length1 > 0) {
		_tmp5_ = TRUE;
	} else {
		const gchar* _tmp7_;
		_tmp7_ = subsystem;
		_tmp5_ = g_strcmp0 (_tmp7_, "block") == 0;
	}
	_tmp8_ = _tmp5_;
	if (_tmp8_) {
		_tmp4_ = TRUE;
	} else {
		const gchar* _tmp9_;
		_tmp9_ = subsystem;
		_tmp4_ = g_strcmp0 (_tmp9_, "usb") == 0;
	}
	_tmp10_ = _tmp4_;
	if (_tmp10_) {
		{
			const gchar* _tmp11_;
			const gchar* _tmp12_;
			guint8* _tmp13_;
			gint _tmp13__length1;
			const gchar* _tmp14_;
			_tmp11_ = node_path;
			g_debug ("umockdev.vala:810: create_node_for_device: creating file device %s", _tmp11_);
			_tmp12_ = node_path;
			_tmp13_ = node_contents;
			_tmp13__length1 = node_contents_length1;
			g_file_set_contents (_tmp12_, (const char*) _tmp13_, (size_t) _tmp13__length1, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_FILE_ERROR) {
					goto __catch8_g_file_error;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_tmp14_ = subsystem;
			if (g_strcmp0 (_tmp14_, "block") == 0) {
				const gchar* _tmp15_;
				_tmp15_ = node_path;
				g_chmod (_tmp15_, 01644);
			}
		}
		goto __finally8;
		__catch8_g_file_error:
		{
			GError* e = NULL;
			FILE* _tmp16_;
			const gchar* _tmp17_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp16_ = stderr;
			_tmp17_ = e->message;
			fprintf (_tmp16_, "Cannot create dev node file: %s\n", _tmp17_);
			abort ();
			_g_error_free0 (e);
		}
		__finally8:
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == UMOCKDEV_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		return;
	}
	_tmp18_ = g_new0 (gchar, 8192);
	ptyname_array = _tmp18_;
	ptyname_array_length1 = 8192;
	_ptyname_array_size_ = ptyname_array_length1;
	_tmp19_ = ptyname_array;
	_tmp19__length1 = ptyname_array_length1;
	_tmp22_ = openpty (&_tmp20_, &_tmp21_, _tmp19_, NULL, NULL);
	ptym = _tmp20_;
	ptys = _tmp21_;
	_vala_assert (_tmp22_ == 0, "Linux.openpty (out ptym, out ptys, ptyname_array, null, null) == 0");
	_tmp23_ = ptyname_array;
	_tmp23__length1 = ptyname_array_length1;
	_tmp24_ = g_strdup ((const gchar*) _tmp23_);
	ptyname = _tmp24_;
	_tmp25_ = node_path;
	_tmp26_ = ptyname;
	g_debug ("umockdev.vala:829: create_node_for_device: creating pty device %s: got" \
" pty %s", _tmp25_, _tmp26_);
	_tmp27_ = ptys;
	close (_tmp27_);
	_tmp28_ = ptym;
	_tmp30_ = tcgetattr (_tmp28_, &_tmp29_);
	ios = _tmp29_;
	_vala_assert (_tmp30_ == 0, "Posix.tcgetattr (ptym, out ios) == 0");
	_tmp31_ = ios.c_iflag;
	ios.c_iflag = _tmp31_ & (~((IGNCR | INLCR) | ICRNL));
	_tmp32_ = ios.c_oflag;
	ios.c_oflag = _tmp32_ & (~(ONLCR | OCRNL));
	_tmp33_ = ios.c_lflag;
	ios.c_lflag = _tmp33_ & (~(ICANON | ECHO));
	_tmp34_ = ptym;
	_tmp35_ = ios;
	_tmp36_ = tcsetattr (_tmp34_, TCSANOW, &_tmp35_);
	_vala_assert (_tmp36_ == 0, "Posix.tcsetattr (ptym, Posix.TCSANOW, ios) == 0");
	_tmp37_ = ptyname;
	_tmp38_ = node_path;
	_tmp39_ = symlink (_tmp37_, _tmp38_);
	_vala_assert (_tmp39_ == 0, "FileUtils.symlink (ptyname, node_path) == 0");
	_tmp40_ = node_path;
	_tmp41_ = self->priv->root_dir;
	_tmp42_ = strlen (_tmp41_);
	_tmp43_ = _tmp42_;
	_tmp44_ = string_substring (_tmp40_, (glong) _tmp43_, (glong) (-1));
	devname = _tmp44_;
	_tmp45_ = self->priv->dev_fd;
	_tmp46_ = devname;
	_tmp47_ = g_hash_table_contains (_tmp45_, _tmp46_);
	_vala_assert (!_tmp47_, "!this.dev_fd.contains (devname)");
	_tmp48_ = self->priv->dev_fd;
	_tmp49_ = devname;
	_tmp50_ = g_strdup (_tmp49_);
	_tmp51_ = ptym;
	g_hash_table_insert (_tmp48_, _tmp50_, (gpointer) ((gintptr) _tmp51_));
	_g_free0 (devname);
	_g_free0 (ptyname);
	ptyname_array = (g_free (ptyname_array), NULL);
}


/**
     * umockdev_testbed_record_parse_line:
     * @data: String to parse
     * @type: Pointer to a gchar which will get the line type (one of P, N,
     *        S, E, or H)
     * @key:  Pointer to a string which will get the key name; this will be
     *        set to %NULL for line types which do not have a key (P, N, S). You
     *        need to free this with g_free().
     * @value: Pointer to a string which will get the value. You need to
     *         free this with g_free().
     *
     * Parse one line from a device record file.
     *
     * Returns: Pointer to the next line start in @data, or %NULL if the first line
     * is not valid.
     */
static gchar* umockdev_testbed_record_parse_line (UMockdevTestbed* self, const gchar* data, gchar* type, gchar** key, gchar** val) {
	gchar _vala_type = '\0';
	gchar* _vala_key = NULL;
	gchar* _vala_val = NULL;
	gchar* result = NULL;
	GMatchInfo* match = NULL;
	GRegex* _tmp0_;
	const gchar* _tmp1_;
	GMatchInfo* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	GMatchInfo* _tmp24_;
	gchar* _tmp25_ = NULL;
	gchar* type_str;
	const gchar* _tmp26_;
	const gchar* _tmp27_;
	gchar _tmp28_ = '\0';
	gint end_pos = 0;
	GMatchInfo* _tmp29_;
	gint _tmp30_ = 0;
	gboolean _tmp31_ = FALSE;
	const gchar* _tmp32_;
	gint _tmp33_;
	gchar* _tmp34_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (data != NULL, NULL);
	_tmp0_ = self->priv->re_record_val;
	_tmp1_ = data;
	_tmp3_ = g_regex_match (_tmp0_, _tmp1_, 0, &_tmp2_);
	_g_match_info_free0 (match);
	match = _tmp2_;
	if (_tmp3_) {
		GMatchInfo* _tmp4_;
		gchar* _tmp5_ = NULL;
		_g_free0 (_vala_key);
		_vala_key = NULL;
		_tmp4_ = match;
		_tmp5_ = g_match_info_fetch (_tmp4_, 2);
		_g_free0 (_vala_val);
		_vala_val = _tmp5_;
	} else {
		GRegex* _tmp6_;
		const gchar* _tmp7_;
		GMatchInfo* _tmp8_ = NULL;
		gboolean _tmp9_ = FALSE;
		_tmp6_ = self->priv->re_record_keyval;
		_tmp7_ = data;
		_tmp9_ = g_regex_match (_tmp6_, _tmp7_, 0, &_tmp8_);
		_g_match_info_free0 (match);
		match = _tmp8_;
		if (_tmp9_) {
			GMatchInfo* _tmp10_;
			gchar* _tmp11_ = NULL;
			GMatchInfo* _tmp12_;
			gchar* _tmp13_ = NULL;
			const gchar* _tmp14_;
			_tmp10_ = match;
			_tmp11_ = g_match_info_fetch (_tmp10_, 2);
			_g_free0 (_vala_key);
			_vala_key = _tmp11_;
			_tmp12_ = match;
			_tmp13_ = g_match_info_fetch (_tmp12_, 3);
			_g_free0 (_vala_val);
			_vala_val = _tmp13_;
			_tmp14_ = _vala_val;
			_vala_assert (_tmp14_ != NULL, "val != null");
		} else {
			GRegex* _tmp15_;
			const gchar* _tmp16_;
			GMatchInfo* _tmp17_ = NULL;
			gboolean _tmp18_ = FALSE;
			_tmp15_ = self->priv->re_record_optval;
			_tmp16_ = data;
			_tmp18_ = g_regex_match (_tmp15_, _tmp16_, 0, &_tmp17_);
			_g_match_info_free0 (match);
			match = _tmp17_;
			if (_tmp18_) {
				GMatchInfo* _tmp19_;
				gchar* _tmp20_ = NULL;
				GMatchInfo* _tmp21_;
				gchar* _tmp22_ = NULL;
				_tmp19_ = match;
				_tmp20_ = g_match_info_fetch (_tmp19_, 2);
				_g_free0 (_vala_key);
				_vala_key = _tmp20_;
				_tmp21_ = match;
				_tmp22_ = g_match_info_fetch (_tmp21_, 3);
				_g_free0 (_vala_val);
				_vala_val = _tmp22_;
			} else {
				const gchar* _tmp23_;
				_tmp23_ = data;
				g_debug ("umockdev.vala:881: record_parse_line: >%s< does not match anything, fa" \
"iling", _tmp23_);
				_vala_type = '\0';
				_g_free0 (_vala_key);
				_vala_key = NULL;
				_g_free0 (_vala_val);
				_vala_val = NULL;
				result = NULL;
				_g_match_info_free0 (match);
				if (type) {
					*type = _vala_type;
				}
				if (key) {
					*key = _vala_key;
				} else {
					_g_free0 (_vala_key);
				}
				if (val) {
					*val = _vala_val;
				} else {
					_g_free0 (_vala_val);
				}
				return result;
			}
		}
	}
	_tmp24_ = match;
	_tmp25_ = g_match_info_fetch (_tmp24_, 1);
	type_str = _tmp25_;
	_tmp26_ = type_str;
	_vala_assert (_tmp26_ != NULL, "type_str != null");
	_tmp27_ = type_str;
	_tmp28_ = string_get (_tmp27_, (glong) 0);
	_vala_type = _tmp28_;
	_tmp29_ = match;
	_tmp31_ = g_match_info_fetch_pos (_tmp29_, 0, NULL, &_tmp30_);
	end_pos = _tmp30_;
	_vala_assert (_tmp31_, "match.fetch_pos(0, null, out end_pos)");
	_tmp32_ = data;
	_tmp33_ = end_pos;
	_tmp34_ = string_substring (_tmp32_, (glong) _tmp33_, (glong) (-1));
	result = _tmp34_;
	_g_free0 (type_str);
	_g_match_info_free0 (match);
	if (type) {
		*type = _vala_type;
	}
	if (key) {
		*key = _vala_key;
	} else {
		_g_free0 (_vala_key);
	}
	if (val) {
		*val = _vala_val;
	} else {
		_g_free0 (_vala_val);
	}
	return result;
}


/**
     * umockdev_testbed_disable:
     * @self: A #UMockdevTestbed.
     *
     * Disable the testbed.  This can be used for temporarily switching back to
     * the real /sys and /dev without having to destroy or change $UMOCKDEV_DIR
     * and the #UMockdevTestbed instance. Use @umockdev_testbed_enable() to
     * re-enable the testbed.
     */
void umockdev_testbed_disable (UMockdevTestbed* self) {
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	FILE* _tmp3_ = NULL;
	FILE* _tmp4_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->root_dir;
	_tmp1_ = g_build_filename (_tmp0_, "disabled", NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_fopen (_tmp2_, "w");
	_tmp4_ = _tmp3_;
	_fclose0 (_tmp4_);
	_g_free0 (_tmp2_);
}


/**
     * umockdev_testbed_enable:
     * @self: A #UMockdevTestbed.
     *
     * Re-enable the testbed after @@umockdev_testbed_disable().
     */
void umockdev_testbed_enable (UMockdevTestbed* self) {
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->root_dir;
	_tmp1_ = g_build_filename (_tmp0_, "disabled", NULL);
	_tmp2_ = _tmp1_;
	g_remove (_tmp2_);
	_g_free0 (_tmp2_);
}


/**
     * umockdev_testbed_clear:
     * @self: A #UMockdevTestbed.
     *
     * Remove all added devices from testbed directory.  After that, the
     * umockdev root directory will be in the same state as directly after the
     * constructor.
     */
void umockdev_testbed_clear (UMockdevTestbed* self) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->root_dir;
	umockdev_remove_dir (_tmp0_, FALSE);
	_tmp1_ = self->priv->sys_dir;
	g_mkdir (_tmp1_, 0755);
}


/**
     * umockdev_testbed_get_dev_fd:
     * @self: A #UMockdevTestbed.
     * @devnode: Device node name ("/dev/...")
     *
     * Simulated devices without a pre-defined contents are backed by a
     * stream-like device node (PTY). Return the file descriptor
     * for accessing their "master" side, i. e. the end that gets
     * controlled by test suites. The tested program opens the "slave" side,
     * which is just openening the device specified by @devnode, e. g.
     * /dev/ttyUSB2. Once that happened, your test can directly communicate
     * with the tested program over that descriptor.
     *
     * Returns: File descriptor for communicating with clients that connect to
     *           @devnode, or -1 if @devnode does not exist or is not a
     *           simulated stream device. This must not be closed!
     */
gint umockdev_testbed_get_dev_fd (UMockdevTestbed* self, const gchar* devnode) {
	gint result = 0;
	GHashTable* _tmp0_;
	const gchar* _tmp1_;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (devnode != NULL, 0);
	_tmp0_ = self->priv->dev_fd;
	_tmp1_ = devnode;
	_tmp2_ = g_hash_table_contains (_tmp0_, _tmp1_);
	if (_tmp2_) {
		GHashTable* _tmp3_;
		const gchar* _tmp4_;
		gconstpointer _tmp5_ = NULL;
		_tmp3_ = self->priv->dev_fd;
		_tmp4_ = devnode;
		_tmp5_ = g_hash_table_lookup (_tmp3_, _tmp4_);
		result = (gint) ((gintptr) _tmp5_);
		return result;
	} else {
		result = -1;
		return result;
	}
}


static void umockdev_testbed_class_init (UMockdevTestbedClass * klass) {
	umockdev_testbed_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UMockdevTestbedPrivate));
	G_OBJECT_CLASS (klass)->finalize = umockdev_testbed_finalize;
}


static void umockdev_testbed_instance_init (UMockdevTestbed * self) {
	self->priv = UMOCKDEV_TESTBED_GET_PRIVATE (self);
	self->priv->ev_sender = NULL;
}


static void umockdev_testbed_finalize (GObject* obj) {
	UMockdevTestbed * self;
	GHashTable* _tmp0_;
	GList* _tmp1_ = NULL;
	GHashTable* _tmp3_;
	GHashTable* _tmp4_;
	GList* _tmp5_ = NULL;
	const gchar* _tmp8_;
	const gchar* _tmp9_;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UMOCKDEV_TYPE_TESTBED, UMockdevTestbed);
	_tmp0_ = self->priv->dev_script_runner;
	_tmp1_ = g_hash_table_get_values (_tmp0_);
	{
		GList* r_collection = NULL;
		GList* r_it = NULL;
		r_collection = _tmp1_;
		for (r_it = r_collection; r_it != NULL; r_it = r_it->next) {
			UMockdevScriptRunner* r = NULL;
			r = (UMockdevScriptRunner*) r_it->data;
			{
				UMockdevScriptRunner* _tmp2_;
				_tmp2_ = r;
				umockdev_script_runner_stop (_tmp2_);
			}
		}
		_g_list_free0 (r_collection);
	}
	_tmp3_ = self->priv->dev_script_runner;
	g_hash_table_remove_all (_tmp3_);
	_tmp4_ = self->priv->dev_fd;
	_tmp5_ = g_hash_table_get_values (_tmp4_);
	{
		GList* fd_collection = NULL;
		GList* fd_it = NULL;
		fd_collection = _tmp5_;
		for (fd_it = fd_collection; fd_it != NULL; fd_it = fd_it->next) {
			gint fd = 0;
			fd = (gint) ((gintptr) fd_it->data);
			{
				gint _tmp6_;
				gint _tmp7_;
				_tmp6_ = fd;
				g_debug ("umockdev.vala:88: closing master pty fd %i for emulated device", _tmp6_);
				_tmp7_ = fd;
				close (_tmp7_);
			}
		}
		_g_list_free0 (fd_collection);
	}
	_tmp8_ = self->priv->root_dir;
	g_debug ("umockdev.vala:92: Removing test bed %s", _tmp8_);
	_tmp9_ = self->priv->root_dir;
	umockdev_remove_dir (_tmp9_, TRUE);
	g_unsetenv ("UMOCKDEV_DIR");
	_g_free0 (self->priv->root_dir);
	_g_free0 (self->priv->sys_dir);
	_g_regex_unref0 (self->priv->re_record_val);
	_g_regex_unref0 (self->priv->re_record_keyval);
	_g_regex_unref0 (self->priv->re_record_optval);
	_uevent_sender_close0 (self->priv->ev_sender);
	_g_hash_table_unref0 (self->priv->dev_fd);
	_g_hash_table_unref0 (self->priv->dev_script_runner);
	G_OBJECT_CLASS (umockdev_testbed_parent_class)->finalize (obj);
}


/**
 * UMockdevTestbed:
 *
 * The #UMockdevTestbed class builds a temporary sandbox for mock devices.
 * You can add a number of devices including arbitrary sysfs attributes and
 * udev properties, and then run your software in that test bed that is
 * independent of the actual hardware it is running on.  With this you can
 * simulate particular hardware in virtual environments up to some degree,
 * without needing any particular privileges or disturbing the whole system.
 *
 * You can either add devices by specifying individual device paths,
 * properties, and attributes, or use the umockdev-record tool to create a human
 * readable/editable record of a real device (and all its parents) and load
 * that into the testbed with umockdev_testbed_add_from_string().
 *
 * Instantiating a #UMockdevTestbed object creates a temporary directory with
 * an empty sysfs tree and sets the $UMOCKDEV_DIR environment variable so that
 * programs subsequently started under umockdev-wrapper will use the test bed
 * instead of the system's real sysfs.
 */
GType umockdev_testbed_get_type (void) {
	static volatile gsize umockdev_testbed_type_id__volatile = 0;
	if (g_once_init_enter (&umockdev_testbed_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UMockdevTestbedClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) umockdev_testbed_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UMockdevTestbed), 0, (GInstanceInitFunc) umockdev_testbed_instance_init, NULL };
		GType umockdev_testbed_type_id;
		umockdev_testbed_type_id = g_type_register_static (G_TYPE_OBJECT, "UMockdevTestbed", &g_define_type_info, 0);
		g_once_init_leave (&umockdev_testbed_type_id__volatile, umockdev_testbed_type_id);
	}
	return umockdev_testbed_type_id__volatile;
}


void umockdev_remove_dir (const gchar* path, gboolean remove_toplevel) {
	gboolean _tmp0_ = FALSE;
	const gchar* _tmp1_;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp5_;
	gboolean _tmp20_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (path != NULL);
	_tmp1_ = path;
	_tmp2_ = g_file_test (_tmp1_, G_FILE_TEST_IS_DIR);
	if (_tmp2_) {
		const gchar* _tmp3_;
		gboolean _tmp4_ = FALSE;
		_tmp3_ = path;
		_tmp4_ = g_file_test (_tmp3_, G_FILE_TEST_IS_SYMLINK);
		_tmp0_ = !_tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp5_ = _tmp0_;
	if (_tmp5_) {
		GDir* d = NULL;
		gchar* name = NULL;
		{
			const gchar* _tmp6_;
			GDir* _tmp7_ = NULL;
			GDir* _tmp8_;
			_tmp6_ = path;
			_tmp7_ = g_dir_open (_tmp6_, (guint) 0, &_inner_error_);
			_tmp8_ = _tmp7_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_FILE_ERROR) {
					goto __catch9_g_file_error;
				}
				_g_dir_close0 (d);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_g_dir_close0 (d);
			d = _tmp8_;
		}
		goto __finally9;
		__catch9_g_file_error:
		{
			GError* e = NULL;
			const gchar* _tmp9_;
			GError* _tmp10_;
			const gchar* _tmp11_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp9_ = path;
			_tmp10_ = e;
			_tmp11_ = _tmp10_->message;
			g_warning ("umockdev.vala:984: cannot open: %s: %s", _tmp9_, _tmp11_);
			_g_error_free0 (e);
			_g_dir_close0 (d);
			return;
		}
		__finally9:
		if (_inner_error_ != NULL) {
			_g_dir_close0 (d);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		while (TRUE) {
			GDir* _tmp12_;
			const gchar* _tmp13_ = NULL;
			gchar* _tmp14_;
			const gchar* _tmp15_;
			const gchar* _tmp16_;
			const gchar* _tmp17_;
			gchar* _tmp18_ = NULL;
			gchar* _tmp19_;
			_tmp12_ = d;
			_tmp13_ = g_dir_read_name (_tmp12_);
			_tmp14_ = g_strdup (_tmp13_);
			_g_free0 (name);
			name = _tmp14_;
			_tmp15_ = name;
			if (!(_tmp15_ != NULL)) {
				break;
			}
			_tmp16_ = path;
			_tmp17_ = name;
			_tmp18_ = g_build_filename (_tmp16_, _tmp17_, NULL);
			_tmp19_ = _tmp18_;
			umockdev_remove_dir (_tmp19_, TRUE);
			_g_free0 (_tmp19_);
		}
		_g_free0 (name);
		_g_dir_close0 (d);
	}
	_tmp20_ = remove_toplevel;
	if (_tmp20_) {
		const gchar* _tmp21_;
		gint _tmp22_ = 0;
		_tmp21_ = path;
		_tmp22_ = g_remove (_tmp21_);
		if (_tmp22_ < 0) {
			const gchar* _tmp23_;
			gint _tmp24_;
			const gchar* _tmp25_ = NULL;
			_tmp23_ = path;
			_tmp24_ = errno;
			_tmp25_ = g_strerror (_tmp24_);
			g_warning ("umockdev.vala:995: cannot remove %s: %s", _tmp23_, _tmp25_);
		}
	}
}


static gint string_index_of_char (const gchar* self, gunichar c, gint start_index) {
	gint result = 0;
	gint _tmp0_;
	gunichar _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _result_;
	gchar* _tmp3_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = c;
	_tmp2_ = g_utf8_strchr (((gchar*) self) + _tmp0_, (gssize) (-1), _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


gchar* umockdev_make_dotdots (const gchar* path) {
	gchar* result = NULL;
	gint offset;
	guint count;
	gchar* _tmp6_;
	gchar* dots;
	g_return_val_if_fail (path != NULL, NULL);
	offset = 0;
	count = (guint) 0;
	while (TRUE) {
		const gchar* _tmp0_;
		gint _tmp1_;
		gint _tmp2_ = 0;
		gint _tmp3_;
		guint _tmp4_;
		gint _tmp5_;
		_tmp0_ = path;
		_tmp1_ = offset;
		_tmp2_ = string_index_of_char (_tmp0_, (gunichar) '/', _tmp1_);
		offset = _tmp2_;
		_tmp3_ = offset;
		if (!(_tmp3_ >= 0)) {
			break;
		}
		_tmp4_ = count;
		count = _tmp4_ + 1;
		_tmp5_ = offset;
		offset = _tmp5_ + 1;
	}
	_tmp6_ = g_strdup ("");
	dots = _tmp6_;
	while (TRUE) {
		guint _tmp7_;
		const gchar* _tmp8_;
		gchar* _tmp9_;
		guint _tmp10_;
		_tmp7_ = count;
		if (!(_tmp7_ > ((guint) 1))) {
			break;
		}
		_tmp8_ = dots;
		_tmp9_ = g_strconcat (_tmp8_, "../", NULL);
		_g_free0 (dots);
		dots = _tmp9_;
		_tmp10_ = count;
		count = _tmp10_ - 1;
	}
	result = dots;
	return result;
}


guint8 umockdev_hexdigit (gchar c) {
	guint8 result = 0U;
	gint _tmp0_ = 0;
	gchar _tmp1_;
	gint _tmp8_;
	_tmp1_ = c;
	if (_tmp1_ >= 'a') {
		gchar _tmp2_;
		_tmp2_ = c;
		_tmp0_ = (_tmp2_ - 'a') + 10;
	} else {
		gint _tmp3_ = 0;
		gchar _tmp4_;
		gint _tmp7_;
		_tmp4_ = c;
		if (_tmp4_ >= 'A') {
			gchar _tmp5_;
			_tmp5_ = c;
			_tmp3_ = (_tmp5_ - 'A') + 10;
		} else {
			gchar _tmp6_;
			_tmp6_ = c;
			_tmp3_ = (gint) (_tmp6_ - '0');
		}
		_tmp7_ = _tmp3_;
		_tmp0_ = _tmp7_;
	}
	_tmp8_ = _tmp0_;
	result = (guint8) _tmp8_;
	return result;
}


guint8* umockdev_decode_hex (const gchar* data, int* result_length1, GError** error) {
	guint8* result = NULL;
	const gchar* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	const gchar* _tmp5_;
	gint _tmp6_;
	gint _tmp7_;
	gint len;
	gint _tmp8_;
	guint8* _tmp9_ = NULL;
	guint8* bin;
	gint bin_length1;
	gint _bin_size_;
	guint8* _tmp26_;
	gint _tmp26__length1;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (data != NULL, NULL);
	_tmp0_ = data;
	_tmp1_ = strlen (_tmp0_);
	_tmp2_ = _tmp1_;
	if ((_tmp2_ % 2) != 0) {
		const gchar* _tmp3_;
		GError* _tmp4_;
		_tmp3_ = data;
		_tmp4_ = g_error_new (UMOCKDEV_ERROR, UMOCKDEV_ERROR_PARSE, "malformed hexadecimal value: %s", _tmp3_);
		_inner_error_ = _tmp4_;
		if (_inner_error_->domain == UMOCKDEV_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp5_ = data;
	_tmp6_ = strlen (_tmp5_);
	_tmp7_ = _tmp6_;
	len = _tmp7_;
	_tmp8_ = len;
	_tmp9_ = g_new0 (guint8, _tmp8_ / 2);
	bin = _tmp9_;
	bin_length1 = _tmp8_ / 2;
	_bin_size_ = bin_length1;
	{
		guint i;
		i = (guint) 0;
		{
			gboolean _tmp10_;
			_tmp10_ = TRUE;
			while (TRUE) {
				gboolean _tmp11_;
				guint _tmp13_;
				guint8* _tmp14_;
				gint _tmp14__length1;
				guint8* _tmp15_;
				gint _tmp15__length1;
				guint _tmp16_;
				const gchar* _tmp17_;
				guint _tmp18_;
				gchar _tmp19_ = '\0';
				guint8 _tmp20_ = 0U;
				const gchar* _tmp21_;
				guint _tmp22_;
				gchar _tmp23_ = '\0';
				guint8 _tmp24_ = 0U;
				guint8 _tmp25_;
				_tmp11_ = _tmp10_;
				if (!_tmp11_) {
					guint _tmp12_;
					_tmp12_ = i;
					i = _tmp12_ + 1;
				}
				_tmp10_ = FALSE;
				_tmp13_ = i;
				_tmp14_ = bin;
				_tmp14__length1 = bin_length1;
				if (!(_tmp13_ < ((guint) _tmp14__length1))) {
					break;
				}
				_tmp15_ = bin;
				_tmp15__length1 = bin_length1;
				_tmp16_ = i;
				_tmp17_ = data;
				_tmp18_ = i;
				_tmp19_ = string_get (_tmp17_, (glong) (_tmp18_ * 2));
				_tmp20_ = umockdev_hexdigit (_tmp19_);
				_tmp21_ = data;
				_tmp22_ = i;
				_tmp23_ = string_get (_tmp21_, (glong) ((_tmp22_ * 2) + 1));
				_tmp24_ = umockdev_hexdigit (_tmp23_);
				_tmp15_[_tmp16_] = (guint8) ((_tmp20_ << 4) | _tmp24_);
				_tmp25_ = _tmp15_[_tmp16_];
			}
		}
	}
	_tmp26_ = bin;
	_tmp26__length1 = bin_length1;
	if (result_length1) {
		*result_length1 = _tmp26__length1;
	}
	result = _tmp26_;
	return result;
}


gchar* umockdev_find_devnode (const gchar* devpath) {
	gchar* result = NULL;
	gchar* devname;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	GFile* _tmp3_ = NULL;
	GFile* _tmp4_;
	GFile* f;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (devpath != NULL, NULL);
	devname = NULL;
	_tmp0_ = devpath;
	_tmp1_ = g_build_filename (_tmp0_, "uevent", NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_file_new_for_path (_tmp2_);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	f = _tmp4_;
	{
		GFile* _tmp5_;
		GFileInputStream* _tmp6_ = NULL;
		GFileInputStream* _tmp7_;
		GFileInputStream* _tmp8_;
		GDataInputStream* _tmp9_;
		GDataInputStream* _tmp10_;
		GDataInputStream* inp;
		gchar* line = NULL;
		gsize len = 0UL;
		GDataInputStream* _tmp24_;
		_tmp5_ = f;
		_tmp6_ = g_file_read (_tmp5_, NULL, &_inner_error_);
		_tmp7_ = _tmp6_;
		if (_inner_error_ != NULL) {
			goto __catch10_g_error;
		}
		_tmp8_ = _tmp7_;
		_tmp9_ = g_data_input_stream_new ((GInputStream*) _tmp8_);
		_tmp10_ = _tmp9_;
		_g_object_unref0 (_tmp8_);
		inp = _tmp10_;
		while (TRUE) {
			GDataInputStream* _tmp11_;
			gsize _tmp12_ = 0UL;
			gchar* _tmp13_ = NULL;
			gchar* _tmp14_;
			const gchar* _tmp15_;
			const gchar* _tmp16_;
			gboolean _tmp17_ = FALSE;
			_tmp11_ = inp;
			_tmp13_ = g_data_input_stream_read_line (_tmp11_, &_tmp12_, NULL, &_inner_error_);
			len = _tmp12_;
			_tmp14_ = _tmp13_;
			if (_inner_error_ != NULL) {
				_g_free0 (line);
				_g_object_unref0 (inp);
				goto __catch10_g_error;
			}
			_g_free0 (line);
			line = _tmp14_;
			_tmp15_ = line;
			if (!(_tmp15_ != NULL)) {
				break;
			}
			_tmp16_ = line;
			_tmp17_ = g_str_has_prefix (_tmp16_, "DEVNAME=");
			if (_tmp17_) {
				const gchar* _tmp18_;
				gchar* _tmp19_ = NULL;
				const gchar* _tmp20_;
				gboolean _tmp21_ = FALSE;
				_tmp18_ = line;
				_tmp19_ = string_substring (_tmp18_, (glong) 8, (glong) (-1));
				_g_free0 (devname);
				devname = _tmp19_;
				_tmp20_ = devname;
				_tmp21_ = g_str_has_prefix (_tmp20_, "/dev/");
				if (!_tmp21_) {
					const gchar* _tmp22_;
					gchar* _tmp23_;
					_tmp22_ = devname;
					_tmp23_ = g_strconcat ("/dev/", _tmp22_, NULL);
					_g_free0 (devname);
					devname = _tmp23_;
				}
				break;
			}
		}
		_tmp24_ = inp;
		g_input_stream_close ((GInputStream*) _tmp24_, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_free0 (line);
			_g_object_unref0 (inp);
			goto __catch10_g_error;
		}
		_g_free0 (line);
		_g_object_unref0 (inp);
	}
	goto __finally10;
	__catch10_g_error:
	{
		GError* e = NULL;
		GError* _tmp25_;
		const gchar* _tmp26_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp25_ = e;
		_tmp26_ = _tmp25_->message;
		g_warning ("umockdev.vala:1063: Cannot read uevent file: %s\n", _tmp26_);
		_g_error_free0 (e);
	}
	__finally10:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (f);
		_g_free0 (devname);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = devname;
	_g_object_unref0 (f);
	return result;
}


static gpointer _umockdev_script_runner_run_gthread_func (gpointer self) {
	gpointer result;
	result = umockdev_script_runner_run (self);
	umockdev_script_runner_unref (self);
	return result;
}


UMockdevScriptRunner* umockdev_script_runner_construct (GType object_type, const gchar* device, const gchar* script_file, gint fd, GError** error) {
	UMockdevScriptRunner* self = NULL;
	const gchar* _tmp0_;
	FILE* _tmp1_ = NULL;
	FILE* _tmp2_;
	const gchar* _tmp8_;
	const gchar* _tmp9_;
	gchar* _tmp10_;
	gint _tmp11_;
	const gchar* _tmp12_;
	GThread* _tmp13_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (device != NULL, NULL);
	g_return_val_if_fail (script_file != NULL, NULL);
	self = (UMockdevScriptRunner*) g_type_create_instance (object_type);
	_tmp0_ = script_file;
	_tmp1_ = g_fopen (_tmp0_, "r");
	_fclose0 (self->priv->script);
	self->priv->script = _tmp1_;
	_tmp2_ = self->priv->script;
	if (_tmp2_ == NULL) {
		const gchar* _tmp3_;
		gchar* _tmp4_;
		gchar* _tmp5_;
		GError* _tmp6_;
		GError* _tmp7_;
		_tmp3_ = script_file;
		_tmp4_ = g_strconcat ("Cannot open script record file ", _tmp3_, NULL);
		_tmp5_ = _tmp4_;
		_tmp6_ = g_error_new_literal (G_FILE_ERROR, G_FILE_ERROR_FAILED, _tmp5_);
		_tmp7_ = _tmp6_;
		_g_free0 (_tmp5_);
		_inner_error_ = _tmp7_;
		if (_inner_error_->domain == G_FILE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_umockdev_script_runner_unref0 (self);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp8_ = device;
	umockdev_script_runner_set_device (self, _tmp8_);
	_tmp9_ = script_file;
	_tmp10_ = g_strdup (_tmp9_);
	_g_free0 (self->priv->script_file);
	self->priv->script_file = _tmp10_;
	_tmp11_ = fd;
	self->priv->fd = _tmp11_;
	self->priv->running = TRUE;
	_tmp12_ = device;
	_tmp13_ = g_thread_new (_tmp12_, _umockdev_script_runner_run_gthread_func, umockdev_script_runner_ref (self));
	_g_thread_unref0 (self->priv->thread);
	self->priv->thread = _tmp13_;
	return self;
}


UMockdevScriptRunner* umockdev_script_runner_new (const gchar* device, const gchar* script_file, gint fd, GError** error) {
	return umockdev_script_runner_construct (UMOCKDEV_TYPE_SCRIPT_RUNNER, device, script_file, fd, error);
}


void umockdev_script_runner_stop (UMockdevScriptRunner* self) {
	gboolean _tmp0_;
	const gchar* _tmp1_;
	GThread* _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->running;
	if (!_tmp0_) {
		return;
	}
	_tmp1_ = self->priv->_device;
	g_debug ("umockdev.vala:1094: Stopping script runner for %s: joining thread", _tmp1_);
	self->priv->running = FALSE;
	_tmp2_ = self->priv->thread;
	g_thread_join (_tmp2_);
}


static void* umockdev_script_runner_run (UMockdevScriptRunner* self) {
	void* result = NULL;
	gchar op = '\0';
	guint32 delta = 0U;
	guint8* data = NULL;
	gint data_length1 = 0;
	gint _data_size_ = 0;
	const gchar* _tmp0_;
	const gchar* _tmp23_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_device;
	g_debug ("umockdev.vala:1105: ScriptRunner[%s]: start", _tmp0_);
	while (TRUE) {
		gboolean _tmp1_;
		gchar _tmp2_ = '\0';
		guint32 _tmp3_ = 0U;
		gint _tmp4_ = 0;
		guint8* _tmp5_ = NULL;
		gchar _tmp6_;
		_tmp1_ = self->priv->running;
		if (!_tmp1_) {
			break;
		}
		_tmp5_ = umockdev_script_runner_next_line (self, &_tmp2_, &_tmp3_, &_tmp4_);
		op = _tmp2_;
		delta = _tmp3_;
		data = (g_free (data), NULL);
		data = _tmp5_;
		data_length1 = _tmp4_;
		_data_size_ = data_length1;
		_tmp6_ = op;
		switch (_tmp6_) {
			case 'r':
			{
				const gchar* _tmp7_;
				guint32 _tmp8_;
				guint32 _tmp9_;
				const gchar* _tmp10_;
				guint8* _tmp11_;
				gint _tmp11__length1;
				gint _tmp12_;
				guint8* _tmp13_;
				gint _tmp13__length1;
				guint8* _tmp14_;
				gint _tmp14__length1;
				gssize _tmp15_ = 0L;
				guint8* _tmp16_;
				gint _tmp16__length1;
				_tmp7_ = self->priv->_device;
				_tmp8_ = delta;
				g_debug ("ScriptRunner[%s]: read op; sleeping %" G_GUINT32_FORMAT " ms", _tmp7_, _tmp8_);
				_tmp9_ = delta;
				g_usleep ((gulong) (_tmp9_ * 1000));
				_tmp10_ = self->priv->_device;
				_tmp11_ = data;
				_tmp11__length1 = data_length1;
				g_debug ("umockdev.vala:1115: ScriptRunner[%s]: read op after sleep; writing dat" \
"a '%s'", _tmp10_, (const gchar*) _tmp11_);
				_tmp12_ = self->priv->fd;
				_tmp13_ = data;
				_tmp13__length1 = data_length1;
				_tmp14_ = data;
				_tmp14__length1 = data_length1;
				_tmp15_ = write (_tmp12_, _tmp13_, (gsize) (_tmp14__length1 - 1));
				_tmp16_ = data;
				_tmp16__length1 = data_length1;
				_vala_assert (_tmp15_ == ((gssize) (_tmp16__length1 - 1)), "Posix.write (this.fd, data, data.length - 1) == data.length - 1");
				break;
			}
			case 'w':
			{
				const gchar* _tmp17_;
				guint8* _tmp18_;
				gint _tmp18__length1;
				guint8* _tmp19_;
				gint _tmp19__length1;
				guint32 _tmp20_;
				_tmp17_ = self->priv->_device;
				_tmp18_ = data;
				_tmp18__length1 = data_length1;
				g_debug ("umockdev.vala:1120: ScriptRunner[%s]: write op, data '%s'", _tmp17_, (const gchar*) _tmp18_);
				_tmp19_ = data;
				_tmp19__length1 = data_length1;
				_tmp20_ = delta;
				umockdev_script_runner_op_write (self, _tmp19_, _tmp19__length1, _tmp20_);
				break;
			}
			case 'Q':
			{
				self->priv->running = FALSE;
				break;
			}
			default:
			{
				const gchar* _tmp21_;
				gchar _tmp22_;
				_tmp21_ = self->priv->_device;
				_tmp22_ = op;
				g_debug ("umockdev.vala:1129: ScriptRunner[%s]: got unknown line op %c, ignoring", _tmp21_, (gint) _tmp22_);
				break;
			}
		}
	}
	_tmp23_ = self->priv->_device;
	g_debug ("umockdev.vala:1134: ScriptRunner[%s]: not running any more, ending thr" \
"ead", _tmp23_);
	result = NULL;
	data = (g_free (data), NULL);
	return result;
}


static gchar* g_file_stream_read_line (FILE* self) {
	gchar* result = NULL;
	gint c = 0;
	GString* ret;
	GString* _tmp7_;
	g_return_val_if_fail (self != NULL, NULL);
	ret = NULL;
	while (TRUE) {
		gint _tmp0_ = 0;
		gint _tmp1_;
		GString* _tmp2_;
		gint _tmp4_;
		GString* _tmp5_;
		gint _tmp6_;
		_tmp0_ = fgetc (self);
		c = _tmp0_;
		_tmp1_ = c;
		if (!(_tmp1_ != EOF)) {
			break;
		}
		_tmp2_ = ret;
		if (_tmp2_ == NULL) {
			GString* _tmp3_;
			_tmp3_ = g_string_new ("");
			_g_string_free0 (ret);
			ret = _tmp3_;
		}
		_tmp4_ = c;
		if (_tmp4_ == ((gint) '\n')) {
			break;
		}
		_tmp5_ = ret;
		_tmp6_ = c;
		g_string_append_c ((GString*) _tmp5_, (gchar) _tmp6_);
	}
	_tmp7_ = ret;
	if (_tmp7_ == NULL) {
		result = NULL;
		_g_string_free0 (ret);
		return result;
	} else {
		GString* _tmp8_;
		const gchar* _tmp9_;
		gchar* _tmp10_;
		_tmp8_ = ret;
		_tmp9_ = ((GString*) _tmp8_)->str;
		_tmp10_ = g_strdup (_tmp9_);
		result = _tmp10_;
		_g_string_free0 (ret);
		return result;
	}
	_g_string_free0 (ret);
}


static void _vala_array_add11 (guint8** array, int* length, int* size, guint8 value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (guint8, *array, *size);
	}
	(*array)[(*length)++] = value;
}


static void _vala_array_add12 (guint8** array, int* length, int* size, guint8 value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (guint8, *array, *size);
	}
	(*array)[(*length)++] = value;
}


static void _vala_array_add13 (guint8** array, int* length, int* size, guint8 value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (guint8, *array, *size);
	}
	(*array)[(*length)++] = value;
}


static guint8* umockdev_script_runner_next_line (UMockdevScriptRunner* self, gchar* op, guint32* delta, int* result_length1) {
	gchar _vala_op = '\0';
	guint32 _vala_delta = 0U;
	guint8* result = NULL;
	gint c = 0;
	FILE* _tmp11_;
	glong _tmp12_ = 0L;
	glong cur_pos;
	FILE* _tmp13_;
	gint _tmp14_ = 0;
	FILE* _tmp18_;
	glong _tmp19_ = 0L;
	FILE* _tmp20_;
	gint _tmp21_ = 0;
	FILE* _tmp25_;
	gchar* _tmp26_ = NULL;
	gchar* line;
	const gchar* _tmp27_;
	guint8* _tmp28_ = NULL;
	guint8* data;
	gint data_length1;
	gint _data_size_;
	guint8* _tmp65_;
	gint _tmp65__length1;
	guint8* _tmp66_;
	gint _tmp66__length1;
	g_return_val_if_fail (self != NULL, NULL);
	{
		gboolean _tmp0_;
		_tmp0_ = TRUE;
		while (TRUE) {
			gboolean _tmp1_;
			FILE* _tmp2_;
			gint _tmp3_ = 0;
			gint _tmp4_;
			_tmp1_ = _tmp0_;
			if (!_tmp1_) {
			}
			_tmp0_ = FALSE;
			_tmp2_ = self->priv->script;
			_tmp3_ = fgetc (_tmp2_);
			c = _tmp3_;
			_tmp4_ = c;
			if (_tmp4_ == EOF) {
				const gchar* _tmp5_;
				const gchar* _tmp6_;
				guint8* _tmp7_ = NULL;
				guint8* _tmp8_;
				gint _tmp8__length1;
				_tmp5_ = self->priv->_device;
				_tmp6_ = self->priv->script_file;
				g_debug ("umockdev.vala:1145: ScriptRunner[%s]: end of script %s, closing", _tmp5_, _tmp6_);
				_vala_op = 'Q';
				_vala_delta = (guint32) 0;
				_tmp7_ = g_new0 (guint8, 0);
				_tmp8_ = _tmp7_;
				_tmp8__length1 = 0;
				if (result_length1) {
					*result_length1 = _tmp8__length1;
				}
				result = _tmp8_;
				if (op) {
					*op = _vala_op;
				}
				if (delta) {
					*delta = _vala_delta;
				}
				return result;
			} else {
				gint _tmp9_;
				_tmp9_ = c;
				if (_tmp9_ != ((gint) '\n')) {
					gint _tmp10_;
					_tmp10_ = c;
					_vala_op = (gchar) _tmp10_;
					break;
				}
			}
		}
	}
	_tmp11_ = self->priv->script;
	_tmp12_ = ftell (_tmp11_);
	cur_pos = _tmp12_;
	_tmp13_ = self->priv->script;
	_tmp14_ = fgetc (_tmp13_);
	if (_tmp14_ != ((gint) ' ')) {
		FILE* _tmp15_;
		const gchar* _tmp16_;
		glong _tmp17_;
		_tmp15_ = stderr;
		_tmp16_ = self->priv->script_file;
		_tmp17_ = cur_pos;
		fprintf (_tmp15_, "Missing space after operation code in %s at position %li\n", _tmp16_, _tmp17_);
		abort ();
	}
	_tmp18_ = self->priv->script;
	_tmp19_ = ftell (_tmp18_);
	cur_pos = _tmp19_;
	_tmp20_ = self->priv->script;
	_tmp21_ = fscanf (_tmp20_, "%" G_GUINT32_FORMAT " ", &_vala_delta);
	if (_tmp21_ != 1) {
		FILE* _tmp22_;
		const gchar* _tmp23_;
		glong _tmp24_;
		_tmp22_ = stderr;
		_tmp23_ = self->priv->script_file;
		_tmp24_ = cur_pos;
		fprintf (_tmp22_, "Cannot parse time in %s at position %li\n", _tmp23_, _tmp24_);
		abort ();
	}
	_tmp25_ = self->priv->script;
	_tmp26_ = g_file_stream_read_line (_tmp25_);
	line = _tmp26_;
	_tmp27_ = line;
	_vala_assert (_tmp27_ != NULL, "line != null");
	_tmp28_ = g_new0 (guint8, 0);
	data = _tmp28_;
	data_length1 = 0;
	_data_size_ = data_length1;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp29_;
			_tmp29_ = TRUE;
			while (TRUE) {
				gboolean _tmp30_;
				gint _tmp32_;
				const gchar* _tmp33_;
				gint _tmp34_;
				gint _tmp35_;
				const gchar* _tmp36_;
				guint8* _tmp37_;
				gint _tmp37__length1;
				guint8* _tmp38_;
				gint _tmp38__length1;
				gint _tmp39_;
				guint8 _tmp40_;
				_tmp30_ = _tmp29_;
				if (!_tmp30_) {
					gint _tmp31_;
					_tmp31_ = i;
					i = _tmp31_ + 1;
				}
				_tmp29_ = FALSE;
				_tmp32_ = i;
				_tmp33_ = line;
				_tmp34_ = strlen (_tmp33_);
				_tmp35_ = _tmp34_;
				if (!(_tmp32_ < _tmp35_)) {
					break;
				}
				_tmp36_ = line;
				_tmp37_ = string_get_data (_tmp36_, &_tmp37__length1);
				_tmp38_ = _tmp37_;
				_tmp38__length1 = _tmp37__length1;
				_tmp39_ = i;
				_tmp40_ = _tmp38_[_tmp39_];
				if (_tmp40_ == ((guint8) '^')) {
					gint _tmp41_;
					const gchar* _tmp42_;
					gint _tmp43_;
					gint _tmp44_;
					gchar _tmp45_ = '\0';
					const gchar* _tmp46_;
					guint8* _tmp47_;
					gint _tmp47__length1;
					guint8* _tmp48_;
					gint _tmp48__length1;
					gint _tmp49_;
					guint8 _tmp50_;
					guint8* _tmp56_;
					gint _tmp56__length1;
					gchar _tmp57_;
					gint _tmp58_;
					_tmp41_ = i;
					_tmp42_ = line;
					_tmp43_ = strlen (_tmp42_);
					_tmp44_ = _tmp43_;
					_vala_assert ((_tmp41_ + 1) < _tmp44_, "i + 1 < line.length");
					_tmp46_ = line;
					_tmp47_ = string_get_data (_tmp46_, &_tmp47__length1);
					_tmp48_ = _tmp47_;
					_tmp48__length1 = _tmp47__length1;
					_tmp49_ = i;
					_tmp50_ = _tmp48_[_tmp49_ + 1];
					if (_tmp50_ == ((guint8) '`')) {
						_tmp45_ = '^';
					} else {
						const gchar* _tmp51_;
						guint8* _tmp52_;
						gint _tmp52__length1;
						guint8* _tmp53_;
						gint _tmp53__length1;
						gint _tmp54_;
						guint8 _tmp55_;
						_tmp51_ = line;
						_tmp52_ = string_get_data (_tmp51_, &_tmp52__length1);
						_tmp53_ = _tmp52_;
						_tmp53__length1 = _tmp52__length1;
						_tmp54_ = i;
						_tmp55_ = _tmp53_[_tmp54_ + 1];
						_tmp45_ = (gchar) (_tmp55_ - 64);
					}
					_tmp56_ = data;
					_tmp56__length1 = data_length1;
					_tmp57_ = _tmp45_;
					_vala_array_add11 (&data, &data_length1, &_data_size_, (guint8) _tmp57_);
					_tmp58_ = i;
					i = _tmp58_ + 1;
				} else {
					guint8* _tmp59_;
					gint _tmp59__length1;
					const gchar* _tmp60_;
					guint8* _tmp61_;
					gint _tmp61__length1;
					guint8* _tmp62_;
					gint _tmp62__length1;
					gint _tmp63_;
					guint8 _tmp64_;
					_tmp59_ = data;
					_tmp59__length1 = data_length1;
					_tmp60_ = line;
					_tmp61_ = string_get_data (_tmp60_, &_tmp61__length1);
					_tmp62_ = _tmp61_;
					_tmp62__length1 = _tmp61__length1;
					_tmp63_ = i;
					_tmp64_ = _tmp62_[_tmp63_];
					_vala_array_add12 (&data, &data_length1, &_data_size_, _tmp64_);
				}
			}
		}
	}
	_tmp65_ = data;
	_tmp65__length1 = data_length1;
	_vala_array_add13 (&data, &data_length1, &_data_size_, (guint8) 0);
	_tmp66_ = data;
	_tmp66__length1 = data_length1;
	if (result_length1) {
		*result_length1 = _tmp66__length1;
	}
	result = _tmp66_;
	_g_free0 (line);
	if (op) {
		*op = _vala_op;
	}
	if (delta) {
		*delta = _vala_delta;
	}
	return result;
}


static void umockdev_script_runner_op_write (UMockdevScriptRunner* self, guint8* data, int data_length1, guint32 delta) {
	fd_set fds = {0};
	struct timeval _tmp0_ = {0};
	struct timeval timeout;
	guint8* _tmp1_;
	gint _tmp1__length1;
	gsize blksize;
	gsize offset;
	gsize _tmp2_;
	guint8* _tmp3_ = NULL;
	guint8* buf;
	gint buf_length1;
	gint _buf_size_;
	g_return_if_fail (self != NULL);
	_tmp0_.tv_sec = (time_t) 0;
	_tmp0_.tv_usec = (glong) 200000;
	timeout = _tmp0_;
	_tmp1_ = data;
	_tmp1__length1 = data_length1;
	blksize = (gsize) (_tmp1__length1 - 1);
	offset = (gsize) 0;
	_tmp2_ = blksize;
	_tmp3_ = g_new0 (guint8, _tmp2_);
	buf = _tmp3_;
	buf_length1 = _tmp2_;
	_buf_size_ = buf_length1;
	while (TRUE) {
		gboolean _tmp4_ = FALSE;
		gboolean _tmp5_;
		gboolean _tmp8_;
		fd_set _tmp9_ = {0};
		gint _tmp10_;
		gint _tmp11_;
		struct timeval _tmp12_;
		gint _tmp13_ = 0;
		gint res;
		gint _tmp14_;
		gint _tmp20_;
		gint _tmp25_;
		guint8* _tmp26_;
		gint _tmp26__length1;
		gsize _tmp27_;
		gsize _tmp28_;
		gssize _tmp29_ = 0L;
		gssize len;
		gssize _tmp30_;
		guint8* _tmp36_;
		gint _tmp36__length1;
		guint8* _tmp37_;
		gint _tmp37__length1;
		gsize _tmp38_;
		gsize _tmp39_;
		gssize _tmp40_;
		gint _tmp41_ = 0;
		gsize _tmp48_;
		gssize _tmp49_;
		const gchar* _tmp50_;
		gssize _tmp51_;
		gsize _tmp52_;
		gsize _tmp53_;
		_tmp5_ = self->priv->running;
		if (_tmp5_) {
			gsize _tmp6_;
			gsize _tmp7_;
			_tmp6_ = offset;
			_tmp7_ = blksize;
			_tmp4_ = _tmp6_ < _tmp7_;
		} else {
			_tmp4_ = FALSE;
		}
		_tmp8_ = _tmp4_;
		if (!_tmp8_) {
			break;
		}
		FD_ZERO (&_tmp9_);
		fds = _tmp9_;
		_tmp10_ = self->priv->fd;
		FD_SET (_tmp10_, &fds);
		_tmp11_ = self->priv->fd;
		_tmp12_ = timeout;
		_tmp13_ = select (_tmp11_ + 1, &fds, NULL, NULL, &_tmp12_);
		res = _tmp13_;
		_tmp14_ = res;
		if (_tmp14_ < 0) {
			gint _tmp15_;
			FILE* _tmp16_;
			const gchar* _tmp17_;
			gint _tmp18_;
			const gchar* _tmp19_ = NULL;
			_tmp15_ = errno;
			if (_tmp15_ == EINTR) {
				continue;
			}
			_tmp16_ = stderr;
			_tmp17_ = self->priv->_device;
			_tmp18_ = errno;
			_tmp19_ = g_strerror (_tmp18_);
			fprintf (_tmp16_, "ScriptRunner op_write[%s]: select() failed: %s\n", _tmp17_, _tmp19_);
			abort ();
		}
		_tmp20_ = res;
		if (_tmp20_ == 0) {
			const gchar* _tmp21_;
			guint8* _tmp22_;
			gint _tmp22__length1;
			gsize _tmp23_;
			gsize _tmp24_;
			_tmp21_ = self->priv->_device;
			_tmp22_ = data;
			_tmp22__length1 = data_length1;
			_tmp23_ = offset;
			_tmp24_ = blksize;
			g_debug ("umockdev.vala:1212: ScriptRunner[%s]: timed out on read operation on e" \
"xpected block '%s', trying again", _tmp21_, (const gchar*) (_tmp22_ + _tmp23_));
			continue;
		}
		_tmp25_ = self->priv->fd;
		_tmp26_ = buf;
		_tmp26__length1 = buf_length1;
		_tmp27_ = blksize;
		_tmp28_ = offset;
		_tmp29_ = read (_tmp25_, _tmp26_, _tmp27_ - _tmp28_);
		len = _tmp29_;
		_tmp30_ = len;
		if (_tmp30_ <= ((gssize) 0)) {
			const gchar* _tmp31_;
			guint8* _tmp32_;
			gint _tmp32__length1;
			gsize _tmp33_;
			gsize _tmp34_;
			FILE* _tmp35_;
			_tmp31_ = self->priv->_device;
			_tmp32_ = data;
			_tmp32__length1 = data_length1;
			_tmp33_ = offset;
			_tmp34_ = blksize;
			g_debug ("umockdev.vala:1220: ScriptRunner[%s]: got failure or EOF on read opera" \
"tion on expected block '%s', resetting", _tmp31_, (const gchar*) (_tmp32_ + _tmp33_));
			_tmp35_ = self->priv->script;
			fseek (_tmp35_, (glong) 0, SEEK_SET);
			buf = (g_free (buf), NULL);
			return;
		}
		_tmp36_ = buf;
		_tmp36__length1 = buf_length1;
		_tmp37_ = data;
		_tmp37__length1 = data_length1;
		_tmp38_ = offset;
		_tmp39_ = blksize;
		_tmp40_ = len;
		_tmp41_ = memcmp (_tmp36_, _tmp37_ + _tmp38_, (gsize) _tmp40_);
		if (_tmp41_ != 0) {
			FILE* _tmp42_;
			const gchar* _tmp43_;
			guint8* _tmp44_;
			gint _tmp44__length1;
			guint8* _tmp45_;
			gint _tmp45__length1;
			gsize _tmp46_;
			gsize _tmp47_;
			_tmp42_ = stderr;
			_tmp43_ = self->priv->_device;
			_tmp44_ = buf;
			_tmp44__length1 = buf_length1;
			_tmp45_ = data;
			_tmp45__length1 = data_length1;
			_tmp46_ = offset;
			_tmp47_ = blksize;
			fprintf (_tmp42_, "ScriptRunner op_write[%s]: data mismatch; got block '%s', expected blo" \
"ck '%s' (%" G_GSSIZE_FORMAT " bytes)\n", _tmp43_, (const gchar*) _tmp44_, (const gchar*) (_tmp45_ + _tmp46_));
			abort ();
		}
		_tmp48_ = offset;
		_tmp49_ = len;
		offset = _tmp48_ + _tmp49_;
		_tmp50_ = self->priv->_device;
		_tmp51_ = len;
		_tmp52_ = offset;
		_tmp53_ = blksize;
		g_debug ("ScriptRunner[%s]: op_write, got %" G_GSSIZE_FORMAT " bytes; offset: %" G_GSIZE_FORMAT ", full block size %" G_GSIZE_FORMAT, _tmp50_, _tmp51_, _tmp52_, _tmp53_);
	}
	buf = (g_free (buf), NULL);
}


const gchar* umockdev_script_runner_get_device (UMockdevScriptRunner* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_device;
	result = _tmp0_;
	return result;
}


static void umockdev_script_runner_set_device (UMockdevScriptRunner* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_device);
	self->priv->_device = _tmp1_;
}


static void umockdev_value_script_runner_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void umockdev_value_script_runner_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		umockdev_script_runner_unref (value->data[0].v_pointer);
	}
}


static void umockdev_value_script_runner_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = umockdev_script_runner_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer umockdev_value_script_runner_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* umockdev_value_script_runner_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		UMockdevScriptRunner* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = umockdev_script_runner_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* umockdev_value_script_runner_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	UMockdevScriptRunner** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = umockdev_script_runner_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* umockdev_param_spec_script_runner (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	UMockdevParamSpecScriptRunner* spec;
	g_return_val_if_fail (g_type_is_a (object_type, UMOCKDEV_TYPE_SCRIPT_RUNNER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer umockdev_value_get_script_runner (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UMOCKDEV_TYPE_SCRIPT_RUNNER), NULL);
	return value->data[0].v_pointer;
}


void umockdev_value_set_script_runner (GValue* value, gpointer v_object) {
	UMockdevScriptRunner* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UMOCKDEV_TYPE_SCRIPT_RUNNER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, UMOCKDEV_TYPE_SCRIPT_RUNNER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		umockdev_script_runner_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		umockdev_script_runner_unref (old);
	}
}


void umockdev_value_take_script_runner (GValue* value, gpointer v_object) {
	UMockdevScriptRunner* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UMOCKDEV_TYPE_SCRIPT_RUNNER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, UMOCKDEV_TYPE_SCRIPT_RUNNER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		umockdev_script_runner_unref (old);
	}
}


static void umockdev_script_runner_class_init (UMockdevScriptRunnerClass * klass) {
	umockdev_script_runner_parent_class = g_type_class_peek_parent (klass);
	UMOCKDEV_SCRIPT_RUNNER_CLASS (klass)->finalize = umockdev_script_runner_finalize;
	g_type_class_add_private (klass, sizeof (UMockdevScriptRunnerPrivate));
}


static void umockdev_script_runner_instance_init (UMockdevScriptRunner * self) {
	self->priv = UMOCKDEV_SCRIPT_RUNNER_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void umockdev_script_runner_finalize (UMockdevScriptRunner* obj) {
	UMockdevScriptRunner * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UMOCKDEV_TYPE_SCRIPT_RUNNER, UMockdevScriptRunner);
	umockdev_script_runner_stop (self);
	_g_free0 (self->priv->_device);
	_g_free0 (self->priv->script_file);
	_g_thread_unref0 (self->priv->thread);
	_fclose0 (self->priv->script);
}


GType umockdev_script_runner_get_type (void) {
	static volatile gsize umockdev_script_runner_type_id__volatile = 0;
	if (g_once_init_enter (&umockdev_script_runner_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { umockdev_value_script_runner_init, umockdev_value_script_runner_free_value, umockdev_value_script_runner_copy_value, umockdev_value_script_runner_peek_pointer, "p", umockdev_value_script_runner_collect_value, "p", umockdev_value_script_runner_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (UMockdevScriptRunnerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) umockdev_script_runner_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UMockdevScriptRunner), 0, (GInstanceInitFunc) umockdev_script_runner_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType umockdev_script_runner_type_id;
		umockdev_script_runner_type_id = g_type_register_fundamental (g_type_fundamental_next (), "UMockdevScriptRunner", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&umockdev_script_runner_type_id__volatile, umockdev_script_runner_type_id);
	}
	return umockdev_script_runner_type_id__volatile;
}


gpointer umockdev_script_runner_ref (gpointer instance) {
	UMockdevScriptRunner* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void umockdev_script_runner_unref (gpointer instance) {
	UMockdevScriptRunner* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		UMOCKDEV_SCRIPT_RUNNER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


GQuark umockdev_error_quark (void) {
	return g_quark_from_static_string ("umockdev_error-quark");
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



