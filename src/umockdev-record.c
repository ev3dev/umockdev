/* umockdev-record.c generated by valac 0.20.1, the Vala compiler
 * generated from umockdev-record.vala, do not modify */

/*
 * Record Linux devices and their ancestors from sysfs/udev.
 * All attributes and properties are included, non-ASCII ones get printed in hex.
 * The record is written to the standard output.
 *
 * Copyright (C) 2013 Canonical Ltd.
 * Author: Martin Pitt <martin.pitt@ubuntu.com>
 *
 * umockdev is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * umockdev is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include <sys/stat.h>
#include <errno.h>
#include <sys/types.h>
#include <glib/gstdio.h>
#include <fcntl.h>
#include <unistd.h>
#include "config.h"

#define _g_dir_close0(var) ((var == NULL) ? NULL : (var = (g_dir_close (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_ptr_array_unref0(var) ((var == NULL) ? NULL : (var = (g_ptr_array_unref (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
#define __g_list_free__g_free0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_free0_ (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);


extern guint record_script_counter;
guint record_script_counter = (guint) 0;
extern gchar** opt_devices;
gchar** opt_devices = NULL;
extern gboolean opt_all;
gboolean opt_all = FALSE;
extern gchar* opt_ioctl;
gchar* opt_ioctl = NULL;
extern gchar** opt_script;
gchar** opt_script = NULL;
extern gboolean opt_version;
gboolean opt_version = FALSE;

void exit_error (const gchar* message, ...);
void devices_from_dir (const gchar* dir, GPtrArray** devs);
gchar** all_devices (void);
static void _g_free0_ (gpointer var);
static gchar** _vala_array_dup1 (gchar** self, int length);
gchar* resolve (const gchar* dev);
gchar* parent (const gchar* dev);
gchar* format_hex (guint8* bytes, int bytes_length1, gint len);
void write_attr (const gchar* name, guint8* val, int val_length1);
gchar* dev_contents (const gchar* dev);
void record_device (const gchar* dev);
static void _g_list_free__g_free0_ (GList* self);
void dump_devices (gchar** devices, int devices_length1);
void split_devfile_arg (const gchar* arg, gchar** devnum, gchar** fname);
void record_ioctl (const gchar* arg);
void record_script (const gchar* arg);
gint _vala_main (gchar** args, int args_length1);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

const GOptionEntry options[6] = {{"all", 'a', 0, G_OPTION_ARG_NONE, &opt_all, "Record all devices"}, {"ioctl", 'i', 0, G_OPTION_ARG_FILENAME, &opt_ioctl, "Trace ioctls on the device, record into given file. In this case, all " \
"positional arguments are a command (and its arguments) to run that get" \
"s traced.", "devname=FILE"}, {"script", 's', 0, G_OPTION_ARG_FILENAME_ARRAY, &opt_script, "Trace reads and writes on the device, record into given file. In this " \
"case, all positional arguments are a command (and its arguments) to ru" \
"n that gets traced. Can be specified multiple times.", "devname=FILE"}, {"", (gchar) 0, 0, G_OPTION_ARG_STRING_ARRAY, &opt_devices, "Path of a device in /dev or /sys, or command and arguments with --ioct" \
"l.", "DEVICE [...]"}, {"version", (gchar) 0, 0, G_OPTION_ARG_NONE, &opt_version, "Output version information and exit"}, {NULL}};

void exit_error (const gchar* message, ...) {
	FILE* _tmp0_;
	const gchar* _tmp1_;
	va_list _tmp2_ = {0};
	FILE* _tmp3_;
	g_return_if_fail (message != NULL);
	_tmp0_ = stderr;
	_tmp1_ = message;
	va_start (_tmp2_, message);
	vfprintf (_tmp0_, _tmp1_, _tmp2_);
	va_end (_tmp2_);
	_tmp3_ = stderr;
	fputs ("\n", _tmp3_);
	exit (1);
}


void devices_from_dir (const gchar* dir, GPtrArray** devs) {
	GDir* d = NULL;
	gboolean has_uevent;
	gboolean has_subsystem;
	gchar* entry = NULL;
	gboolean _tmp26_ = FALSE;
	gboolean _tmp27_;
	gboolean _tmp29_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (dir != NULL);
	g_return_if_fail (*devs != NULL);
	{
		const gchar* _tmp0_;
		GDir* _tmp1_ = NULL;
		GDir* _tmp2_;
		_tmp0_ = dir;
		_tmp1_ = g_dir_open (_tmp0_, (guint) 0, &_inner_error_);
		_tmp2_ = _tmp1_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch0_g_file_error;
			}
			_g_dir_close0 (d);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_g_dir_close0 (d);
		d = _tmp2_;
	}
	goto __finally0;
	__catch0_g_file_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
		_g_dir_close0 (d);
		return;
	}
	__finally0:
	if (_inner_error_ != NULL) {
		_g_dir_close0 (d);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	has_uevent = FALSE;
	has_subsystem = FALSE;
	while (TRUE) {
		GDir* _tmp3_;
		const gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		const gchar* _tmp6_;
		const gchar* _tmp7_;
		_tmp3_ = d;
		_tmp4_ = g_dir_read_name (_tmp3_);
		_tmp5_ = g_strdup (_tmp4_);
		_g_free0 (entry);
		entry = _tmp5_;
		_tmp6_ = entry;
		if (!(_tmp6_ != NULL)) {
			break;
		}
		_tmp7_ = entry;
		if (g_strcmp0 (_tmp7_, "uevent") == 0) {
			has_uevent = TRUE;
		} else {
			const gchar* _tmp8_;
			_tmp8_ = entry;
			if (g_strcmp0 (_tmp8_, "subsystem") == 0) {
				has_subsystem = TRUE;
			} else {
				const gchar* _tmp9_;
				const gchar* _tmp10_;
				gchar* _tmp11_ = NULL;
				gchar* p;
				struct stat st = {0};
				gboolean _tmp12_ = FALSE;
				gboolean _tmp13_ = FALSE;
				const gchar* _tmp14_;
				struct stat _tmp15_ = {0};
				gint _tmp16_ = 0;
				gboolean _tmp20_;
				gboolean _tmp24_;
				_tmp9_ = dir;
				_tmp10_ = entry;
				_tmp11_ = g_build_filename (_tmp9_, _tmp10_, NULL);
				p = _tmp11_;
				_tmp14_ = p;
				_tmp16_ = lstat (_tmp14_, &_tmp15_);
				st = _tmp15_;
				if (_tmp16_ == 0) {
					struct stat _tmp17_;
					mode_t _tmp18_;
					gboolean _tmp19_ = FALSE;
					_tmp17_ = st;
					_tmp18_ = _tmp17_.st_mode;
					_tmp19_ = S_ISDIR (_tmp18_);
					_tmp13_ = _tmp19_;
				} else {
					_tmp13_ = FALSE;
				}
				_tmp20_ = _tmp13_;
				if (_tmp20_) {
					struct stat _tmp21_;
					mode_t _tmp22_;
					gboolean _tmp23_ = FALSE;
					_tmp21_ = st;
					_tmp22_ = _tmp21_.st_mode;
					_tmp23_ = S_ISLNK (_tmp22_);
					_tmp12_ = !_tmp23_;
				} else {
					_tmp12_ = FALSE;
				}
				_tmp24_ = _tmp12_;
				if (_tmp24_) {
					const gchar* _tmp25_;
					_tmp25_ = p;
					devices_from_dir (_tmp25_, devs);
				}
				_g_free0 (p);
			}
		}
	}
	_tmp27_ = has_uevent;
	if (_tmp27_) {
		gboolean _tmp28_;
		_tmp28_ = has_subsystem;
		_tmp26_ = _tmp28_;
	} else {
		_tmp26_ = FALSE;
	}
	_tmp29_ = _tmp26_;
	if (_tmp29_) {
		GPtrArray* _tmp30_;
		const gchar* _tmp31_;
		gchar* _tmp32_;
		_tmp30_ = *devs;
		_tmp31_ = dir;
		_tmp32_ = g_strdup (_tmp31_);
		g_ptr_array_add (_tmp30_, _tmp32_);
	}
	_g_free0 (entry);
	_g_dir_close0 (d);
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static gchar** _vala_array_dup1 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


gchar** all_devices (void) {
	gchar** result = NULL;
	GPtrArray* _tmp0_;
	GPtrArray* devs;
	GPtrArray* _tmp1_;
	gpointer* _tmp2_;
	gint _tmp2__length1;
	gchar** _tmp3_;
	gint _tmp3__length1;
	_tmp0_ = g_ptr_array_new_with_free_func (_g_free0_);
	devs = _tmp0_;
	devices_from_dir ("/sys/devices", &devs);
	_tmp1_ = devs;
	_tmp2_ = _tmp1_->pdata;
	_tmp2__length1 = (gint) _tmp1_->len;
	_tmp3_ = (_tmp2_ != NULL) ? _vala_array_dup1 (_tmp2_, _tmp2__length1) : ((gpointer) _tmp2_);
	_tmp3__length1 = _tmp2__length1;
	result = _tmp3_;
	_g_ptr_array_unref0 (devs);
	return result;
}


gchar* resolve (const gchar* dev) {
	gchar* result = NULL;
	struct stat st = {0};
	const gchar* _tmp0_;
	struct stat _tmp1_ = {0};
	gint _tmp2_ = 0;
	struct stat _tmp6_;
	dev_t _tmp7_;
	guint _tmp8_ = 0U;
	guint major;
	struct stat _tmp9_;
	dev_t _tmp10_;
	guint _tmp11_ = 0U;
	guint minor;
	gchar* link = NULL;
	struct stat _tmp12_;
	mode_t _tmp13_;
	gboolean _tmp14_ = FALSE;
	const gchar* _tmp26_;
	gchar* _tmp27_ = NULL;
	gchar* real;
	const gchar* _tmp28_;
	const gchar* _tmp31_;
	gchar* _tmp32_ = NULL;
	gchar* _tmp33_;
	gboolean _tmp34_ = FALSE;
	gboolean _tmp35_;
	g_return_val_if_fail (dev != NULL, NULL);
	_tmp0_ = dev;
	_tmp2_ = stat (_tmp0_, &_tmp1_);
	st = _tmp1_;
	if (_tmp2_ != 0) {
		const gchar* _tmp3_;
		gint _tmp4_;
		const gchar* _tmp5_ = NULL;
		_tmp3_ = dev;
		_tmp4_ = errno;
		_tmp5_ = g_strerror (_tmp4_);
		exit_error ("Cannot access device %s: %s", _tmp3_, _tmp5_, NULL);
	}
	_tmp6_ = st;
	_tmp7_ = _tmp6_.st_rdev;
	_tmp8_ = major (_tmp7_);
	major = _tmp8_;
	_tmp9_ = st;
	_tmp10_ = _tmp9_.st_rdev;
	_tmp11_ = minor (_tmp10_);
	minor = _tmp11_;
	_tmp12_ = st;
	_tmp13_ = _tmp12_.st_mode;
	_tmp14_ = S_ISCHR (_tmp13_);
	if (_tmp14_) {
		guint _tmp15_;
		guint _tmp16_;
		gchar* _tmp17_ = NULL;
		_tmp15_ = major;
		_tmp16_ = minor;
		_tmp17_ = g_strdup_printf ("/sys/dev/char/%u:%u", _tmp15_, _tmp16_);
		_g_free0 (link);
		link = _tmp17_;
	} else {
		struct stat _tmp18_;
		mode_t _tmp19_;
		gboolean _tmp20_ = FALSE;
		_tmp18_ = st;
		_tmp19_ = _tmp18_.st_mode;
		_tmp20_ = S_ISBLK (_tmp19_);
		if (_tmp20_) {
			guint _tmp21_;
			guint _tmp22_;
			gchar* _tmp23_ = NULL;
			_tmp21_ = major;
			_tmp22_ = minor;
			_tmp23_ = g_strdup_printf ("/sys/dev/block/%u:%u", _tmp21_, _tmp22_);
			_g_free0 (link);
			link = _tmp23_;
		} else {
			const gchar* _tmp24_;
			gchar* _tmp25_;
			_tmp24_ = dev;
			_tmp25_ = g_strdup (_tmp24_);
			_g_free0 (link);
			link = _tmp25_;
		}
	}
	_tmp26_ = link;
	_tmp27_ = realpath (_tmp26_, NULL);
	real = _tmp27_;
	_tmp28_ = real;
	if (_tmp28_ == NULL) {
		const gchar* _tmp29_;
		gchar* _tmp30_;
		_tmp29_ = link;
		_tmp30_ = g_strdup (_tmp29_);
		_g_free0 (real);
		real = _tmp30_;
	}
	_tmp31_ = real;
	_tmp32_ = g_build_filename (_tmp31_, "uevent", NULL);
	_tmp33_ = _tmp32_;
	_tmp34_ = g_file_test (_tmp33_, G_FILE_TEST_EXISTS);
	_tmp35_ = !_tmp34_;
	_g_free0 (_tmp33_);
	if (_tmp35_) {
		const gchar* _tmp36_;
		_tmp36_ = real;
		exit_error ("Invalid device %s, has no uevent attribute", _tmp36_, NULL);
	}
	result = real;
	_g_free0 (link);
	return result;
}


gchar* parent (const gchar* dev) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* p;
	const gchar* _tmp2_;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	const gchar* _tmp5_;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp9_;
	gboolean _tmp14_;
	const gchar* _tmp15_;
	gchar* _tmp16_ = NULL;
	g_return_val_if_fail (dev != NULL, NULL);
	_tmp0_ = dev;
	_tmp1_ = g_path_get_dirname (_tmp0_);
	p = _tmp1_;
	_tmp2_ = p;
	_tmp3_ = g_str_has_prefix (_tmp2_, "/sys");
	if (!_tmp3_) {
		result = NULL;
		_g_free0 (p);
		return result;
	}
	_tmp5_ = p;
	_tmp6_ = g_build_filename (_tmp5_, "uevent", NULL);
	_tmp7_ = _tmp6_;
	_tmp8_ = g_file_test (_tmp7_, G_FILE_TEST_EXISTS);
	_tmp9_ = _tmp8_;
	_g_free0 (_tmp7_);
	if (_tmp9_) {
		const gchar* _tmp10_;
		gchar* _tmp11_ = NULL;
		gchar* _tmp12_;
		gboolean _tmp13_ = FALSE;
		_tmp10_ = p;
		_tmp11_ = g_build_filename (_tmp10_, "subsystem", NULL);
		_tmp12_ = _tmp11_;
		_tmp13_ = g_file_test (_tmp12_, G_FILE_TEST_EXISTS);
		_tmp4_ = _tmp13_;
		_g_free0 (_tmp12_);
	} else {
		_tmp4_ = FALSE;
	}
	_tmp14_ = _tmp4_;
	if (_tmp14_) {
		result = p;
		return result;
	}
	_tmp15_ = p;
	_tmp16_ = parent (_tmp15_);
	result = _tmp16_;
	_g_free0 (p);
	return result;
}


gchar* format_hex (guint8* bytes, int bytes_length1, gint len) {
	gchar* result = NULL;
	gint _tmp0_;
	GString* _tmp2_;
	GString* _result_;
	GString* _tmp12_;
	const gchar* _tmp13_;
	gchar* _tmp14_;
	_tmp0_ = len;
	if (_tmp0_ < 0) {
		guint8* _tmp1_;
		gint _tmp1__length1;
		_tmp1_ = bytes;
		_tmp1__length1 = bytes_length1;
		len = _tmp1__length1;
	}
	_tmp2_ = g_string_new ("");
	_result_ = _tmp2_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_;
				gint _tmp6_;
				gint _tmp7_;
				GString* _tmp8_;
				guint8* _tmp9_;
				gint _tmp9__length1;
				gint _tmp10_;
				guint8 _tmp11_;
				_tmp4_ = _tmp3_;
				if (!_tmp4_) {
					gint _tmp5_;
					_tmp5_ = i;
					i = _tmp5_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp6_ = i;
				_tmp7_ = len;
				if (!(_tmp6_ < _tmp7_)) {
					break;
				}
				_tmp8_ = _result_;
				_tmp9_ = bytes;
				_tmp9__length1 = bytes_length1;
				_tmp10_ = i;
				_tmp11_ = _tmp9_[_tmp10_];
				g_string_append_printf (_tmp8_, "%02X", (guint) _tmp11_);
			}
		}
	}
	_tmp12_ = _result_;
	_tmp13_ = _tmp12_->str;
	_tmp14_ = g_strdup (_tmp13_);
	result = _tmp14_;
	_g_string_free0 (_result_);
	return result;
}


static gchar* string_chomp (const gchar* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _result_;
	const gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strchomp (_tmp1_);
	result = _result_;
	return result;
}


void write_attr (const gchar* name, guint8* val, int val_length1) {
	guint8* _tmp0_;
	gint _tmp0__length1;
	gchar* _tmp1_;
	gchar* strval;
	gboolean _tmp2_ = FALSE;
	guint8* _tmp3_;
	gint _tmp3__length1;
	const gchar* _tmp4_;
	gint _tmp5_;
	gint _tmp6_;
	gboolean _tmp9_;
	FILE* _tmp22_;
	g_return_if_fail (name != NULL);
	_tmp0_ = val;
	_tmp0__length1 = val_length1;
	_tmp1_ = g_strdup ((const gchar*) _tmp0_);
	strval = _tmp1_;
	_tmp3_ = val;
	_tmp3__length1 = val_length1;
	_tmp4_ = strval;
	_tmp5_ = strlen (_tmp4_);
	_tmp6_ = _tmp5_;
	if (_tmp3__length1 == _tmp6_) {
		const gchar* _tmp7_;
		gboolean _tmp8_ = FALSE;
		_tmp7_ = strval;
		_tmp8_ = g_utf8_validate (_tmp7_, (gssize) (-1), NULL);
		_tmp2_ = _tmp8_;
	} else {
		_tmp2_ = FALSE;
	}
	_tmp9_ = _tmp2_;
	if (_tmp9_) {
		FILE* _tmp10_;
		const gchar* _tmp11_;
		const gchar* _tmp12_;
		gchar* _tmp13_ = NULL;
		gchar* _tmp14_;
		gchar* _tmp15_ = NULL;
		gchar* _tmp16_;
		_tmp10_ = stdout;
		_tmp11_ = name;
		_tmp12_ = strval;
		_tmp13_ = string_chomp (_tmp12_);
		_tmp14_ = _tmp13_;
		_tmp15_ = g_strescape (_tmp14_, "");
		_tmp16_ = _tmp15_;
		fprintf (_tmp10_, "A: %s=%s", _tmp11_, _tmp16_);
		_g_free0 (_tmp16_);
		_g_free0 (_tmp14_);
	} else {
		FILE* _tmp17_;
		const gchar* _tmp18_;
		guint8* _tmp19_;
		gint _tmp19__length1;
		gchar* _tmp20_ = NULL;
		gchar* _tmp21_;
		_tmp17_ = stdout;
		_tmp18_ = name;
		_tmp19_ = val;
		_tmp19__length1 = val_length1;
		_tmp20_ = format_hex (_tmp19_, _tmp19__length1, -1);
		_tmp21_ = _tmp20_;
		fprintf (_tmp17_, "H: %s=%s", _tmp18_, _tmp21_);
		_g_free0 (_tmp21_);
	}
	_tmp22_ = stdout;
	fputc ('\n', _tmp22_);
	_g_free0 (strval);
}


gchar* dev_contents (const gchar* dev) {
	gchar* result = NULL;
	struct stat st = {0};
	const gchar* _tmp0_;
	struct stat _tmp1_ = {0};
	gint _tmp2_ = 0;
	gboolean _tmp4_ = FALSE;
	struct stat _tmp5_;
	mode_t _tmp6_;
	gboolean _tmp7_ = FALSE;
	gboolean _tmp11_;
	const gchar* _tmp13_;
	gint _tmp14_ = 0;
	gint fd;
	gint _tmp15_;
	guint8* _tmp17_ = NULL;
	guint8* buffer;
	gint buffer_length1;
	gint _buffer_size_;
	gint _tmp18_;
	guint8* _tmp19_;
	gint _tmp19__length1;
	gssize _tmp20_ = 0L;
	gssize len;
	gchar* _tmp21_;
	gchar* _result_;
	gboolean _tmp22_ = FALSE;
	gssize _tmp23_;
	gboolean _tmp25_;
	gint _tmp31_;
	g_return_val_if_fail (dev != NULL, NULL);
	_tmp0_ = dev;
	_tmp2_ = lstat (_tmp0_, &_tmp1_);
	st = _tmp1_;
	if (_tmp2_ != 0) {
		gchar* _tmp3_;
		_tmp3_ = g_strdup ("");
		result = _tmp3_;
		return result;
	}
	_tmp5_ = st;
	_tmp6_ = _tmp5_.st_mode;
	_tmp7_ = S_ISCHR (_tmp6_);
	if (!_tmp7_) {
		_tmp4_ = TRUE;
	} else {
		struct stat _tmp8_;
		dev_t _tmp9_;
		guint _tmp10_ = 0U;
		_tmp8_ = st;
		_tmp9_ = _tmp8_.st_rdev;
		_tmp10_ = major (_tmp9_);
		_tmp4_ = _tmp10_ != ((guint) 189);
	}
	_tmp11_ = _tmp4_;
	if (_tmp11_) {
		gchar* _tmp12_;
		_tmp12_ = g_strdup ("");
		result = _tmp12_;
		return result;
	}
	_tmp13_ = dev;
	_tmp14_ = open (_tmp13_, O_RDONLY | O_NONBLOCK, (mode_t) 0);
	fd = _tmp14_;
	_tmp15_ = fd;
	if (_tmp15_ < 0) {
		gchar* _tmp16_;
		_tmp16_ = g_strdup ("");
		result = _tmp16_;
		return result;
	}
	_tmp17_ = g_new0 (guint8, 1025);
	buffer = _tmp17_;
	buffer_length1 = 1025;
	_buffer_size_ = buffer_length1;
	_tmp18_ = fd;
	_tmp19_ = buffer;
	_tmp19__length1 = buffer_length1;
	_tmp20_ = read (_tmp18_, _tmp19_, (gsize) 1025);
	len = _tmp20_;
	_tmp21_ = g_strdup ("");
	_result_ = _tmp21_;
	_tmp23_ = len;
	if (_tmp23_ > ((gssize) 0)) {
		gssize _tmp24_;
		_tmp24_ = len;
		_tmp22_ = _tmp24_ <= ((gssize) 1024);
	} else {
		_tmp22_ = FALSE;
	}
	_tmp25_ = _tmp22_;
	if (_tmp25_) {
		guint8* _tmp26_;
		gint _tmp26__length1;
		gssize _tmp27_;
		gchar* _tmp28_ = NULL;
		gchar* _tmp29_;
		gchar* _tmp30_;
		_tmp26_ = buffer;
		_tmp26__length1 = buffer_length1;
		_tmp27_ = len;
		_tmp28_ = format_hex (_tmp26_, _tmp26__length1, (gint) _tmp27_);
		_tmp29_ = _tmp28_;
		_tmp30_ = g_strconcat ("=", _tmp29_, NULL);
		_g_free0 (_result_);
		_result_ = _tmp30_;
		_g_free0 (_tmp29_);
	}
	_tmp31_ = fd;
	close (_tmp31_);
	result = _result_;
	buffer = (g_free (buffer), NULL);
	return result;
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* _tmp0_;
	glong _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* end;
	gchar* _tmp3_;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_;
	gboolean _tmp3_;
	glong _tmp9_;
	glong _tmp15_;
	glong _tmp18_;
	glong _tmp19_;
	glong _tmp20_;
	glong _tmp21_;
	glong _tmp22_;
	gchar* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		glong _tmp4_;
		glong _tmp5_;
		glong _tmp6_ = 0L;
		_tmp4_ = offset;
		_tmp5_ = len;
		_tmp6_ = string_strnlen ((gchar*) self, _tmp4_ + _tmp5_);
		string_length = _tmp6_;
	} else {
		gint _tmp7_;
		gint _tmp8_;
		_tmp7_ = strlen (self);
		_tmp8_ = _tmp7_;
		string_length = (glong) _tmp8_;
	}
	_tmp9_ = offset;
	if (_tmp9_ < ((glong) 0)) {
		glong _tmp10_;
		glong _tmp11_;
		glong _tmp12_;
		_tmp10_ = string_length;
		_tmp11_ = offset;
		offset = _tmp10_ + _tmp11_;
		_tmp12_ = offset;
		g_return_val_if_fail (_tmp12_ >= ((glong) 0), NULL);
	} else {
		glong _tmp13_;
		glong _tmp14_;
		_tmp13_ = offset;
		_tmp14_ = string_length;
		g_return_val_if_fail (_tmp13_ <= _tmp14_, NULL);
	}
	_tmp15_ = len;
	if (_tmp15_ < ((glong) 0)) {
		glong _tmp16_;
		glong _tmp17_;
		_tmp16_ = string_length;
		_tmp17_ = offset;
		len = _tmp16_ - _tmp17_;
	}
	_tmp18_ = offset;
	_tmp19_ = len;
	_tmp20_ = string_length;
	g_return_val_if_fail ((_tmp18_ + _tmp19_) <= _tmp20_, NULL);
	_tmp21_ = offset;
	_tmp22_ = len;
	_tmp23_ = g_strndup (((gchar*) self) + _tmp21_, (gsize) _tmp22_);
	result = _tmp23_;
	return result;
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = needle;
	_tmp1_ = strstr ((gchar*) self, (gchar*) _tmp0_);
	result = _tmp1_ != NULL;
	return result;
}


static void _g_list_free__g_free0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_free0_, NULL);
	g_list_free (self);
}


void record_device (const gchar* dev) {
	const gchar* _tmp0_;
	gchar* u_out = NULL;
	gint exitcode = 0;
	const gchar* _tmp19_;
	gchar** _tmp20_;
	gchar** _tmp21_ = NULL;
	const gchar* _tmp58_;
	gboolean _tmp59_ = FALSE;
	GDir* d = NULL;
	GList* attributes;
	gchar* entry = NULL;
	GCompareFunc _tmp80_;
	GList* _tmp81_;
	FILE* _tmp104_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (dev != NULL);
	_tmp0_ = dev;
	g_debug ("umockdev-record.vala:170: recording device %s", _tmp0_);
	{
		gchar* _tmp1_;
		gchar* _tmp2_;
		gchar* _tmp3_;
		gchar* _tmp4_;
		const gchar* _tmp5_;
		gchar* _tmp6_;
		gchar** _tmp7_ = NULL;
		gchar** _tmp8_;
		gint _tmp8__length1;
		gchar* _tmp9_ = NULL;
		gint _tmp10_ = 0;
		gint _tmp11_;
		_tmp1_ = g_strdup ("udevadm");
		_tmp2_ = g_strdup ("info");
		_tmp3_ = g_strdup ("--query=all");
		_tmp4_ = g_strdup ("--path");
		_tmp5_ = dev;
		_tmp6_ = g_strdup (_tmp5_);
		_tmp7_ = g_new0 (gchar*, 5 + 1);
		_tmp7_[0] = _tmp1_;
		_tmp7_[1] = _tmp2_;
		_tmp7_[2] = _tmp3_;
		_tmp7_[3] = _tmp4_;
		_tmp7_[4] = _tmp6_;
		_tmp8_ = _tmp7_;
		_tmp8__length1 = 5;
		g_spawn_sync (NULL, _tmp8_, NULL, G_SPAWN_SEARCH_PATH, NULL, NULL, &_tmp9_, NULL, &_tmp10_, &_inner_error_);
		_g_free0 (u_out);
		u_out = _tmp9_;
		exitcode = _tmp10_;
		_tmp8_ = (_vala_array_free (_tmp8_, _tmp8__length1, (GDestroyNotify) g_free), NULL);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_SPAWN_ERROR) {
				goto __catch1_g_spawn_error;
			}
			_g_free0 (u_out);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp11_ = exitcode;
		if (_tmp11_ != 0) {
			gint _tmp12_;
			gchar* _tmp13_ = NULL;
			gchar* _tmp14_;
			GError* _tmp15_;
			GError* _tmp16_;
			_tmp12_ = exitcode;
			_tmp13_ = g_strdup_printf ("udevadm exited with code %i", _tmp12_);
			_tmp14_ = _tmp13_;
			_tmp15_ = g_error_new_literal (G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED, _tmp14_);
			_tmp16_ = _tmp15_;
			_g_free0 (_tmp14_);
			_inner_error_ = _tmp16_;
			if (_inner_error_->domain == G_SPAWN_ERROR) {
				goto __catch1_g_spawn_error;
			}
			_g_free0 (u_out);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	goto __finally1;
	__catch1_g_spawn_error:
	{
		GError* e = NULL;
		GError* _tmp17_;
		const gchar* _tmp18_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp17_ = e;
		_tmp18_ = _tmp17_->message;
		exit_error ("Cannot call udevadm: %s", _tmp18_, NULL);
		_g_error_free0 (e);
	}
	__finally1:
	if (_inner_error_ != NULL) {
		_g_free0 (u_out);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp19_ = u_out;
	_tmp21_ = _tmp20_ = g_strsplit (_tmp19_, "\n", 0);
	{
		gchar** line_collection = NULL;
		gint line_collection_length1 = 0;
		gint _line_collection_size_ = 0;
		gint line_it = 0;
		line_collection = _tmp21_;
		line_collection_length1 = _vala_array_length (_tmp20_);
		for (line_it = 0; line_it < _vala_array_length (_tmp20_); line_it = line_it + 1) {
			gchar* _tmp22_;
			gchar* line = NULL;
			_tmp22_ = g_strdup (line_collection[line_it]);
			line = _tmp22_;
			{
				gboolean _tmp23_ = FALSE;
				gboolean _tmp24_ = FALSE;
				gboolean _tmp25_ = FALSE;
				gboolean _tmp26_ = FALSE;
				const gchar* _tmp27_;
				gint _tmp28_;
				gint _tmp29_;
				gboolean _tmp32_;
				gboolean _tmp35_;
				gboolean _tmp38_;
				gboolean _tmp41_;
				const gchar* _tmp42_;
				gboolean _tmp43_ = FALSE;
				FILE* _tmp55_;
				const gchar* _tmp56_;
				FILE* _tmp57_;
				_tmp27_ = line;
				_tmp28_ = strlen (_tmp27_);
				_tmp29_ = _tmp28_;
				if (_tmp29_ == 0) {
					_tmp26_ = TRUE;
				} else {
					const gchar* _tmp30_;
					gboolean _tmp31_ = FALSE;
					_tmp30_ = line;
					_tmp31_ = g_str_has_prefix (_tmp30_, "E: DEVPATH=");
					_tmp26_ = _tmp31_;
				}
				_tmp32_ = _tmp26_;
				if (_tmp32_) {
					_tmp25_ = TRUE;
				} else {
					const gchar* _tmp33_;
					gboolean _tmp34_ = FALSE;
					_tmp33_ = line;
					_tmp34_ = g_str_has_prefix (_tmp33_, "E: UDEV_LOG=");
					_tmp25_ = _tmp34_;
				}
				_tmp35_ = _tmp25_;
				if (_tmp35_) {
					_tmp24_ = TRUE;
				} else {
					const gchar* _tmp36_;
					gboolean _tmp37_ = FALSE;
					_tmp36_ = line;
					_tmp37_ = g_str_has_prefix (_tmp36_, "E: USEC_INITIALIZED=");
					_tmp24_ = _tmp37_;
				}
				_tmp38_ = _tmp24_;
				if (_tmp38_) {
					_tmp23_ = TRUE;
				} else {
					const gchar* _tmp39_;
					gboolean _tmp40_ = FALSE;
					_tmp39_ = line;
					_tmp40_ = g_str_has_prefix (_tmp39_, "L: ");
					_tmp23_ = _tmp40_;
				}
				_tmp41_ = _tmp23_;
				if (_tmp41_) {
					_g_free0 (line);
					continue;
				}
				_tmp42_ = line;
				_tmp43_ = g_str_has_prefix (_tmp42_, "N: ");
				if (_tmp43_) {
					const gchar* _tmp44_;
					const gchar* _tmp45_;
					gchar* _tmp46_ = NULL;
					gchar* _tmp47_;
					gchar* _tmp48_ = NULL;
					gchar* _tmp49_;
					gchar* _tmp50_;
					gchar* _tmp51_;
					gchar* _tmp52_ = NULL;
					gchar* _tmp53_;
					gchar* _tmp54_;
					_tmp44_ = line;
					_tmp45_ = line;
					_tmp46_ = string_substring (_tmp45_, (glong) 3, (glong) (-1));
					_tmp47_ = _tmp46_;
					_tmp48_ = string_chomp (_tmp47_);
					_tmp49_ = _tmp48_;
					_tmp50_ = g_strconcat ("/dev/", _tmp49_, NULL);
					_tmp51_ = _tmp50_;
					_tmp52_ = dev_contents (_tmp51_);
					_tmp53_ = _tmp52_;
					_tmp54_ = g_strconcat (_tmp44_, _tmp53_, NULL);
					_g_free0 (line);
					line = _tmp54_;
					_g_free0 (_tmp53_);
					_g_free0 (_tmp51_);
					_g_free0 (_tmp49_);
					_g_free0 (_tmp47_);
				}
				_tmp55_ = stdout;
				_tmp56_ = line;
				fputs (_tmp56_, _tmp55_);
				_tmp57_ = stdout;
				fputc ('\n', _tmp57_);
				_g_free0 (line);
			}
		}
		line_collection = (_vala_array_free (line_collection, line_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	_tmp58_ = dev;
	_tmp59_ = string_contains (_tmp58_, "tegra");
	if (_tmp59_) {
		FILE* _tmp60_;
		_tmp60_ = stdout;
		fputc ('\n', _tmp60_);
		_g_free0 (u_out);
		return;
	}
	{
		const gchar* _tmp61_;
		GDir* _tmp62_ = NULL;
		GDir* _tmp63_;
		_tmp61_ = dev;
		_tmp62_ = g_dir_open (_tmp61_, (guint) 0, &_inner_error_);
		_tmp63_ = _tmp62_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch2_g_file_error;
			}
			_g_dir_close0 (d);
			_g_free0 (u_out);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_g_dir_close0 (d);
		d = _tmp63_;
	}
	goto __finally2;
	__catch2_g_file_error:
	{
		GError* e = NULL;
		const gchar* _tmp64_;
		GError* _tmp65_;
		const gchar* _tmp66_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp64_ = dev;
		_tmp65_ = e;
		_tmp66_ = _tmp65_->message;
		exit_error ("Cannot open directory %s: %s", _tmp64_, _tmp66_, NULL);
		_g_error_free0 (e);
		_g_dir_close0 (d);
		_g_free0 (u_out);
		return;
	}
	__finally2:
	if (_inner_error_ != NULL) {
		_g_dir_close0 (d);
		_g_free0 (u_out);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	attributes = NULL;
	while (TRUE) {
		GDir* _tmp67_;
		const gchar* _tmp68_ = NULL;
		gchar* _tmp69_;
		const gchar* _tmp70_;
		gboolean _tmp71_ = FALSE;
		gboolean _tmp72_ = FALSE;
		const gchar* _tmp73_;
		gboolean _tmp75_;
		gboolean _tmp77_;
		_tmp67_ = d;
		_tmp68_ = g_dir_read_name (_tmp67_);
		_tmp69_ = g_strdup (_tmp68_);
		_g_free0 (entry);
		entry = _tmp69_;
		_tmp70_ = entry;
		if (!(_tmp70_ != NULL)) {
			break;
		}
		_tmp73_ = entry;
		if (g_strcmp0 (_tmp73_, "subsystem") != 0) {
			const gchar* _tmp74_;
			_tmp74_ = entry;
			_tmp72_ = g_strcmp0 (_tmp74_, "firmware_node") != 0;
		} else {
			_tmp72_ = FALSE;
		}
		_tmp75_ = _tmp72_;
		if (_tmp75_) {
			const gchar* _tmp76_;
			_tmp76_ = entry;
			_tmp71_ = g_strcmp0 (_tmp76_, "uevent") != 0;
		} else {
			_tmp71_ = FALSE;
		}
		_tmp77_ = _tmp71_;
		if (_tmp77_) {
			const gchar* _tmp78_;
			gchar* _tmp79_;
			_tmp78_ = entry;
			_tmp79_ = g_strdup (_tmp78_);
			attributes = g_list_append (attributes, _tmp79_);
		}
	}
	_tmp80_ = g_strcmp0;
	attributes = g_list_sort (attributes, _tmp80_);
	_tmp81_ = attributes;
	{
		GList* attr_collection = NULL;
		GList* attr_it = NULL;
		attr_collection = _tmp81_;
		for (attr_it = attr_collection; attr_it != NULL; attr_it = attr_it->next) {
			gchar* _tmp82_;
			gchar* attr = NULL;
			_tmp82_ = g_strdup ((const gchar*) attr_it->data);
			attr = _tmp82_;
			{
				const gchar* _tmp83_;
				const gchar* _tmp84_;
				gchar* _tmp85_ = NULL;
				gchar* attr_path;
				const gchar* _tmp86_;
				gboolean _tmp87_ = FALSE;
				_tmp83_ = dev;
				_tmp84_ = attr;
				_tmp85_ = g_build_filename (_tmp83_, _tmp84_, NULL);
				attr_path = _tmp85_;
				_tmp86_ = attr_path;
				_tmp87_ = g_file_test (_tmp86_, G_FILE_TEST_IS_SYMLINK);
				if (_tmp87_) {
					{
						const gchar* _tmp88_;
						gchar* _tmp89_ = NULL;
						gchar* _tmp90_;
						FILE* _tmp91_;
						const gchar* _tmp92_;
						gchar* _tmp93_;
						_tmp88_ = attr_path;
						_tmp89_ = g_file_read_link (_tmp88_, &_inner_error_);
						_tmp90_ = _tmp89_;
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == G_FILE_ERROR) {
								goto __catch3_g_file_error;
							}
							_g_free0 (attr_path);
							_g_free0 (attr);
							_g_free0 (entry);
							__g_list_free__g_free0_0 (attributes);
							_g_dir_close0 (d);
							_g_free0 (u_out);
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
						_tmp91_ = stdout;
						_tmp92_ = attr;
						_tmp93_ = _tmp90_;
						fprintf (_tmp91_, "L: %s=%s\n", _tmp92_, _tmp93_);
						_g_free0 (_tmp93_);
					}
					goto __finally3;
					__catch3_g_file_error:
					{
						GError* e = NULL;
						const gchar* _tmp94_;
						GError* _tmp95_;
						const gchar* _tmp96_;
						e = _inner_error_;
						_inner_error_ = NULL;
						_tmp94_ = attr;
						_tmp95_ = e;
						_tmp96_ = _tmp95_->message;
						exit_error ("Cannot read link %s: %s", _tmp94_, _tmp96_, NULL);
						_g_error_free0 (e);
					}
					__finally3:
					if (_inner_error_ != NULL) {
						_g_free0 (attr_path);
						_g_free0 (attr);
						_g_free0 (entry);
						__g_list_free__g_free0_0 (attributes);
						_g_dir_close0 (d);
						_g_free0 (u_out);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				} else {
					const gchar* _tmp97_;
					gboolean _tmp98_ = FALSE;
					_tmp97_ = attr_path;
					_tmp98_ = g_file_test (_tmp97_, G_FILE_TEST_IS_REGULAR);
					if (_tmp98_) {
						guint8* contents = NULL;
						gint contents_length1 = 0;
						gint _contents_size_ = 0;
						{
							const gchar* _tmp99_;
							guint8* _tmp100_ = NULL;
							size_t _tmp101_;
							const gchar* _tmp102_;
							guint8* _tmp103_;
							gint _tmp103__length1;
							_tmp99_ = attr_path;
							g_file_get_contents (_tmp99_, (gchar**) (&_tmp100_), &_tmp101_, &_inner_error_);
							contents = (g_free (contents), NULL);
							contents = _tmp100_;
							contents_length1 = _tmp101_;
							_contents_size_ = contents_length1;
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == G_FILE_ERROR) {
									goto __catch4_g_file_error;
								}
								contents = (g_free (contents), NULL);
								_g_free0 (attr_path);
								_g_free0 (attr);
								_g_free0 (entry);
								__g_list_free__g_free0_0 (attributes);
								_g_dir_close0 (d);
								_g_free0 (u_out);
								g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
							_tmp102_ = attr;
							_tmp103_ = contents;
							_tmp103__length1 = contents_length1;
							write_attr (_tmp102_, _tmp103_, _tmp103__length1);
						}
						goto __finally4;
						__catch4_g_file_error:
						{
							GError* e = NULL;
							e = _inner_error_;
							_inner_error_ = NULL;
							_g_error_free0 (e);
						}
						__finally4:
						if (_inner_error_ != NULL) {
							contents = (g_free (contents), NULL);
							_g_free0 (attr_path);
							_g_free0 (attr);
							_g_free0 (entry);
							__g_list_free__g_free0_0 (attributes);
							_g_dir_close0 (d);
							_g_free0 (u_out);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
						contents = (g_free (contents), NULL);
					}
				}
				_g_free0 (attr_path);
				_g_free0 (attr);
			}
		}
	}
	_tmp104_ = stdout;
	fputc ('\n', _tmp104_);
	_g_free0 (entry);
	__g_list_free__g_free0_0 (attributes);
	_g_dir_close0 (d);
	_g_free0 (u_out);
}


void dump_devices (gchar** devices, int devices_length1) {
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GHashTable* _tmp2_;
	GHashTable* seen;
	gchar** _tmp3_;
	gint _tmp3__length1;
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, NULL);
	seen = _tmp2_;
	_tmp3_ = devices;
	_tmp3__length1 = devices_length1;
	{
		gchar** device_collection = NULL;
		gint device_collection_length1 = 0;
		gint _device_collection_size_ = 0;
		gint device_it = 0;
		device_collection = _tmp3_;
		device_collection_length1 = _tmp3__length1;
		for (device_it = 0; device_it < _tmp3__length1; device_it = device_it + 1) {
			gchar* _tmp4_;
			gchar* device = NULL;
			_tmp4_ = g_strdup (device_collection[device_it]);
			device = _tmp4_;
			{
				while (TRUE) {
					const gchar* _tmp5_;
					GHashTable* _tmp6_;
					const gchar* _tmp7_;
					gboolean _tmp8_ = FALSE;
					const gchar* _tmp13_;
					gchar* _tmp14_ = NULL;
					_tmp5_ = device;
					if (!(_tmp5_ != NULL)) {
						break;
					}
					_tmp6_ = seen;
					_tmp7_ = device;
					_tmp8_ = g_hash_table_contains (_tmp6_, _tmp7_);
					if (!_tmp8_) {
						GHashTable* _tmp9_;
						const gchar* _tmp10_;
						gchar* _tmp11_ = NULL;
						const gchar* _tmp12_;
						_tmp9_ = seen;
						_tmp10_ = device;
						_tmp11_ = g_strdup (_tmp10_);
						g_hash_table_add (_tmp9_, _tmp11_);
						_tmp12_ = device;
						record_device (_tmp12_);
					}
					_tmp13_ = device;
					_tmp14_ = parent (_tmp13_);
					_g_free0 (device);
					device = _tmp14_;
				}
				_g_free0 (device);
			}
		}
	}
	_g_hash_table_unref0 (seen);
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _result_;
	const gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strstrip (_tmp1_);
	result = _result_;
	return result;
}


void split_devfile_arg (const gchar* arg, gchar** devnum, gchar** fname) {
	gchar* _vala_devnum = NULL;
	gchar* _vala_fname = NULL;
	const gchar* _tmp0_;
	gchar** _tmp1_;
	gchar** _tmp2_ = NULL;
	gchar** parts;
	gint parts_length1;
	gint _parts_size_;
	gchar** _tmp3_;
	gint _tmp3__length1;
	gchar** _tmp4_;
	gint _tmp4__length1;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* dev;
	gchar** _tmp7_;
	gint _tmp7__length1;
	const gchar* _tmp8_;
	gchar* _tmp9_;
	struct stat st = {0};
	const gchar* _tmp10_;
	struct stat _tmp11_ = {0};
	gint _tmp12_ = 0;
	gboolean _tmp16_ = FALSE;
	struct stat _tmp17_;
	mode_t _tmp18_;
	gboolean _tmp19_ = FALSE;
	gboolean _tmp23_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (arg != NULL);
	_tmp0_ = arg;
	_tmp2_ = _tmp1_ = g_strsplit (_tmp0_, "=", 2);
	parts = _tmp2_;
	parts_length1 = _vala_array_length (_tmp1_);
	_parts_size_ = parts_length1;
	_tmp3_ = parts;
	_tmp3__length1 = parts_length1;
	if (_tmp3__length1 != 2) {
		exit_error ("--ioctl argument must be devname=filename", NULL);
	}
	_tmp4_ = parts;
	_tmp4__length1 = parts_length1;
	_tmp5_ = _tmp4_[0];
	_tmp6_ = g_strdup (_tmp5_);
	dev = _tmp6_;
	_tmp7_ = parts;
	_tmp7__length1 = parts_length1;
	_tmp8_ = _tmp7_[1];
	_tmp9_ = g_strdup (_tmp8_);
	_g_free0 (_vala_fname);
	_vala_fname = _tmp9_;
	_tmp10_ = dev;
	_tmp12_ = stat (_tmp10_, &_tmp11_);
	st = _tmp11_;
	if (_tmp12_ != 0) {
		const gchar* _tmp13_;
		gint _tmp14_;
		const gchar* _tmp15_ = NULL;
		_tmp13_ = dev;
		_tmp14_ = errno;
		_tmp15_ = g_strerror (_tmp14_);
		exit_error ("Cannot access device %s: %s", _tmp13_, _tmp15_, NULL);
	}
	_tmp17_ = st;
	_tmp18_ = _tmp17_.st_mode;
	_tmp19_ = S_ISCHR (_tmp18_);
	if (_tmp19_) {
		_tmp16_ = TRUE;
	} else {
		struct stat _tmp20_;
		mode_t _tmp21_;
		gboolean _tmp22_ = FALSE;
		_tmp20_ = st;
		_tmp21_ = _tmp20_.st_mode;
		_tmp22_ = S_ISBLK (_tmp21_);
		_tmp16_ = _tmp22_;
	}
	_tmp23_ = _tmp16_;
	if (_tmp23_) {
		struct stat _tmp24_;
		dev_t _tmp25_;
		guint _tmp26_ = 0U;
		struct stat _tmp27_;
		dev_t _tmp28_;
		guint _tmp29_ = 0U;
		gchar* _tmp30_ = NULL;
		_tmp24_ = st;
		_tmp25_ = _tmp24_.st_rdev;
		_tmp26_ = major (_tmp25_);
		_tmp27_ = st;
		_tmp28_ = _tmp27_.st_rdev;
		_tmp29_ = minor (_tmp28_);
		_tmp30_ = g_strdup_printf ("%u", (_tmp26_ << 8) + _tmp29_);
		_g_free0 (_vala_devnum);
		_vala_devnum = _tmp30_;
	} else {
		gchar* contents = NULL;
		const gchar* _tmp38_;
		gchar* _tmp39_ = NULL;
		gchar* _tmp40_;
		gchar** _tmp41_;
		gchar** _tmp42_ = NULL;
		gchar** _tmp43_;
		gint _tmp43__length1;
		gchar** fields;
		gint fields_length1;
		gint _fields_size_;
		gchar** _tmp44_;
		gint _tmp44__length1;
		gchar** _tmp45_;
		gint _tmp45__length1;
		const gchar* _tmp46_;
		gint _tmp47_ = 0;
		gchar** _tmp48_;
		gint _tmp48__length1;
		const gchar* _tmp49_;
		gint _tmp50_ = 0;
		gchar* _tmp51_ = NULL;
		{
			const gchar* _tmp31_;
			gchar* _tmp32_ = NULL;
			gchar* _tmp33_;
			gchar* _tmp34_ = NULL;
			_tmp31_ = dev;
			_tmp32_ = g_build_filename (_tmp31_, "dev", NULL);
			_tmp33_ = _tmp32_;
			g_file_get_contents (_tmp33_, &_tmp34_, NULL, &_inner_error_);
			_g_free0 (contents);
			contents = _tmp34_;
			_g_free0 (_tmp33_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_FILE_ERROR) {
					goto __catch5_g_file_error;
				}
				_g_free0 (contents);
				_g_free0 (dev);
				parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		goto __finally5;
		__catch5_g_file_error:
		{
			GError* e = NULL;
			const gchar* _tmp35_;
			GError* _tmp36_;
			const gchar* _tmp37_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp35_ = dev;
			_tmp36_ = e;
			_tmp37_ = _tmp36_->message;
			exit_error ("Cannot open %s/dev: %s", _tmp35_, _tmp37_, NULL);
			_g_error_free0 (e);
		}
		__finally5:
		if (_inner_error_ != NULL) {
			_g_free0 (contents);
			_g_free0 (dev);
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp38_ = contents;
		_tmp39_ = string_strip (_tmp38_);
		_tmp40_ = _tmp39_;
		_tmp42_ = _tmp41_ = g_strsplit (_tmp40_, ":", 0);
		_tmp43_ = _tmp42_;
		_tmp43__length1 = _vala_array_length (_tmp41_);
		_g_free0 (_tmp40_);
		fields = _tmp43_;
		fields_length1 = _tmp43__length1;
		_fields_size_ = fields_length1;
		_tmp44_ = fields;
		_tmp44__length1 = fields_length1;
		_vala_assert (_tmp44__length1 == 2, "fields.length == 2");
		_tmp45_ = fields;
		_tmp45__length1 = fields_length1;
		_tmp46_ = _tmp45_[0];
		_tmp47_ = atoi (_tmp46_);
		_tmp48_ = fields;
		_tmp48__length1 = fields_length1;
		_tmp49_ = _tmp48_[1];
		_tmp50_ = atoi (_tmp49_);
		_tmp51_ = g_strdup_printf ("%i", (_tmp47_ << 8) | _tmp50_);
		_g_free0 (_vala_devnum);
		_vala_devnum = _tmp51_;
		fields = (_vala_array_free (fields, fields_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (contents);
	}
	_g_free0 (dev);
	parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
	if (devnum) {
		*devnum = _vala_devnum;
	} else {
		_g_free0 (_vala_devnum);
	}
	if (fname) {
		*fname = _vala_fname;
	} else {
		_g_free0 (_vala_fname);
	}
}


void record_ioctl (const gchar* arg) {
	gchar* devnum = NULL;
	gchar* outfile = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	g_return_if_fail (arg != NULL);
	_tmp0_ = arg;
	split_devfile_arg (_tmp0_, &_tmp1_, &_tmp2_);
	_g_free0 (devnum);
	devnum = _tmp1_;
	_g_free0 (outfile);
	outfile = _tmp2_;
	g_setenv ("UMOCKDEV_IOCTL_RECORD_FILE", outfile, TRUE);
	g_setenv ("UMOCKDEV_IOCTL_RECORD_DEV", devnum, TRUE);
	_g_free0 (outfile);
	_g_free0 (devnum);
}


void record_script (const gchar* arg) {
	gchar* devnum = NULL;
	gchar* outfile = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	guint _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* c;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	guint _tmp9_;
	g_return_if_fail (arg != NULL);
	_tmp0_ = arg;
	split_devfile_arg (_tmp0_, &_tmp1_, &_tmp2_);
	_g_free0 (devnum);
	devnum = _tmp1_;
	_g_free0 (outfile);
	outfile = _tmp2_;
	_tmp3_ = record_script_counter;
	_tmp4_ = g_strdup_printf ("%u", _tmp3_);
	c = _tmp4_;
	_tmp5_ = g_strconcat ("UMOCKDEV_SCRIPT_RECORD_FILE_", c, NULL);
	_tmp6_ = _tmp5_;
	g_setenv (_tmp6_, outfile, TRUE);
	_g_free0 (_tmp6_);
	_tmp7_ = g_strconcat ("UMOCKDEV_SCRIPT_RECORD_DEV_", c, NULL);
	_tmp8_ = _tmp7_;
	g_setenv (_tmp8_, devnum, TRUE);
	_g_free0 (_tmp8_);
	_tmp9_ = record_script_counter;
	record_script_counter = _tmp9_ + 1;
	_g_free0 (c);
	_g_free0 (outfile);
	_g_free0 (devnum);
}


gint _vala_main (gchar** args, int args_length1) {
	gint result = 0;
	GOptionContext* _tmp0_;
	GOptionContext* oc;
	GOptionContext* _tmp1_;
	GOptionContext* _tmp2_;
	gboolean _tmp8_;
	gboolean _tmp10_ = FALSE;
	gboolean _tmp11_;
	gboolean _tmp13_;
	gboolean _tmp14_ = FALSE;
	gboolean _tmp15_;
	gboolean _tmp17_;
	gboolean _tmp18_ = FALSE;
	gboolean _tmp19_ = FALSE;
	const gchar* _tmp20_;
	gboolean _tmp22_;
	gboolean _tmp27_;
	gboolean _tmp28_ = FALSE;
	const gchar* _tmp29_;
	gboolean _tmp31_;
	const gchar* _tmp48_ = NULL;
	gchar* _tmp49_;
	gchar* preload;
	const gchar* _tmp50_;
	const gchar* _tmp54_;
	gchar* _tmp55_;
	gchar* _tmp56_;
	const gchar* _tmp57_;
	gchar** _tmp59_;
	gint _tmp59__length1;
	gchar** _tmp62_;
	gint _tmp62__length1;
	const gchar* _tmp63_;
	gchar** _tmp64_;
	gint _tmp64__length1;
	gchar** _tmp65_;
	gint _tmp65__length1;
	const gchar* _tmp66_;
	gint _tmp67_;
	const gchar* _tmp68_ = NULL;
	GError * _inner_error_ = NULL;
	_tmp0_ = g_option_context_new ("");
	oc = _tmp0_;
	_tmp1_ = oc;
	g_option_context_set_summary (_tmp1_, "Record Linux devices and their ancestors from sysfs/udev, or record io" \
"ctls for a device.");
	_tmp2_ = oc;
	g_option_context_add_main_entries (_tmp2_, options, NULL);
	{
		GOptionContext* _tmp3_;
		_tmp3_ = oc;
		g_option_context_parse (_tmp3_, &args_length1, &args, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_OPTION_ERROR) {
				goto __catch6_g_option_error;
			}
			_g_option_context_free0 (oc);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
	}
	goto __finally6;
	__catch6_g_option_error:
	{
		GError* e = NULL;
		GError* _tmp4_;
		const gchar* _tmp5_;
		gchar** _tmp6_;
		gint _tmp6__length1;
		const gchar* _tmp7_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		_tmp6_ = args;
		_tmp6__length1 = args_length1;
		_tmp7_ = _tmp6_[0];
		exit_error ("Error: %s\nRun %s --help for how to use this program", _tmp5_, _tmp7_, NULL);
		_g_error_free0 (e);
	}
	__finally6:
	if (_inner_error_ != NULL) {
		_g_option_context_free0 (oc);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	_tmp8_ = opt_version;
	if (_tmp8_) {
		FILE* _tmp9_;
		_tmp9_ = stdout;
		fprintf (_tmp9_, "%s\n", VERSION);
		result = 0;
		_g_option_context_free0 (oc);
		return result;
	}
	_tmp11_ = opt_all;
	if (_tmp11_) {
		gchar** _tmp12_;
		gint _tmp12__length1;
		_tmp12_ = opt_devices;
		_tmp12__length1 = _vala_array_length (opt_devices);
		_tmp10_ = _tmp12__length1 > 0;
	} else {
		_tmp10_ = FALSE;
	}
	_tmp13_ = _tmp10_;
	if (_tmp13_) {
		exit_error ("Specifying a device list together with --all is invalid.", NULL);
	}
	_tmp15_ = opt_all;
	if (!_tmp15_) {
		gchar** _tmp16_;
		gint _tmp16__length1;
		_tmp16_ = opt_devices;
		_tmp16__length1 = _vala_array_length (opt_devices);
		_tmp14_ = _tmp16__length1 == 0;
	} else {
		_tmp14_ = FALSE;
	}
	_tmp17_ = _tmp14_;
	if (_tmp17_) {
		exit_error ("Need to specify at least one device or --all.", NULL);
	}
	_tmp20_ = opt_ioctl;
	if (_tmp20_ != NULL) {
		_tmp19_ = TRUE;
	} else {
		gchar** _tmp21_;
		gint _tmp21__length1;
		_tmp21_ = opt_script;
		_tmp21__length1 = _vala_array_length (opt_script);
		_tmp19_ = _tmp21__length1 > 0;
	}
	_tmp22_ = _tmp19_;
	if (_tmp22_) {
		gboolean _tmp23_ = FALSE;
		gboolean _tmp24_;
		gboolean _tmp26_;
		_tmp24_ = opt_all;
		if (_tmp24_) {
			_tmp23_ = TRUE;
		} else {
			gchar** _tmp25_;
			gint _tmp25__length1;
			_tmp25_ = opt_devices;
			_tmp25__length1 = _vala_array_length (opt_devices);
			_tmp23_ = _tmp25__length1 < 1;
		}
		_tmp26_ = _tmp23_;
		_tmp18_ = _tmp26_;
	} else {
		_tmp18_ = FALSE;
	}
	_tmp27_ = _tmp18_;
	if (_tmp27_) {
		exit_error ("For recording ioctls or scripts you have to specify a command to run", NULL);
	}
	_tmp29_ = opt_ioctl;
	if (_tmp29_ == NULL) {
		gchar** _tmp30_;
		gint _tmp30__length1;
		_tmp30_ = opt_script;
		_tmp30__length1 = _vala_array_length (opt_script);
		_tmp28_ = _tmp30__length1 == 0;
	} else {
		_tmp28_ = FALSE;
	}
	_tmp31_ = _tmp28_;
	if (_tmp31_) {
		gboolean _tmp32_;
		gchar** _tmp47_;
		gint _tmp47__length1;
		_tmp32_ = opt_all;
		if (_tmp32_) {
			gchar** _tmp33_;
			gchar** _tmp34_ = NULL;
			_tmp34_ = _tmp33_ = all_devices ();
			opt_devices = (_vala_array_free (opt_devices, _vala_array_length (opt_devices), (GDestroyNotify) g_free), NULL);
			opt_devices = _tmp34_;
		} else {
			{
				gint i;
				i = 0;
				{
					gboolean _tmp35_;
					_tmp35_ = TRUE;
					while (TRUE) {
						gboolean _tmp36_;
						gint _tmp38_;
						gchar** _tmp39_;
						gint _tmp39__length1;
						gchar** _tmp40_;
						gint _tmp40__length1;
						gint _tmp41_;
						gchar** _tmp42_;
						gint _tmp42__length1;
						gint _tmp43_;
						const gchar* _tmp44_;
						gchar* _tmp45_ = NULL;
						gchar* _tmp46_;
						_tmp36_ = _tmp35_;
						if (!_tmp36_) {
							gint _tmp37_;
							_tmp37_ = i;
							i = _tmp37_ + 1;
						}
						_tmp35_ = FALSE;
						_tmp38_ = i;
						_tmp39_ = opt_devices;
						_tmp39__length1 = _vala_array_length (opt_devices);
						if (!(_tmp38_ < _tmp39__length1)) {
							break;
						}
						_tmp40_ = opt_devices;
						_tmp40__length1 = _vala_array_length (opt_devices);
						_tmp41_ = i;
						_tmp42_ = opt_devices;
						_tmp42__length1 = _vala_array_length (opt_devices);
						_tmp43_ = i;
						_tmp44_ = _tmp42_[_tmp43_];
						_tmp45_ = resolve (_tmp44_);
						_g_free0 (_tmp40_[_tmp41_]);
						_tmp40_[_tmp41_] = _tmp45_;
						_tmp46_ = _tmp40_[_tmp41_];
					}
				}
			}
		}
		_tmp47_ = opt_devices;
		_tmp47__length1 = _vala_array_length (opt_devices);
		dump_devices (_tmp47_, _tmp47__length1);
		result = 0;
		_g_option_context_free0 (oc);
		return result;
	}
	_tmp48_ = g_getenv ("LD_PRELOAD");
	_tmp49_ = g_strdup (_tmp48_);
	preload = _tmp49_;
	_tmp50_ = preload;
	if (_tmp50_ == NULL) {
		gchar* _tmp51_;
		_tmp51_ = g_strdup ("");
		_g_free0 (preload);
		preload = _tmp51_;
	} else {
		const gchar* _tmp52_;
		gchar* _tmp53_;
		_tmp52_ = preload;
		_tmp53_ = g_strconcat (_tmp52_, ":", NULL);
		_g_free0 (preload);
		preload = _tmp53_;
	}
	_tmp54_ = preload;
	_tmp55_ = g_strconcat (_tmp54_, "libumockdev-preload.so.0", NULL);
	_tmp56_ = _tmp55_;
	g_setenv ("LD_PRELOAD", _tmp56_, TRUE);
	_g_free0 (_tmp56_);
	_tmp57_ = opt_ioctl;
	if (_tmp57_ != NULL) {
		const gchar* _tmp58_;
		_tmp58_ = opt_ioctl;
		record_ioctl (_tmp58_);
	}
	_tmp59_ = opt_script;
	_tmp59__length1 = _vala_array_length (opt_script);
	{
		gchar** s_collection = NULL;
		gint s_collection_length1 = 0;
		gint _s_collection_size_ = 0;
		gint s_it = 0;
		s_collection = _tmp59_;
		s_collection_length1 = _tmp59__length1;
		for (s_it = 0; s_it < _tmp59__length1; s_it = s_it + 1) {
			gchar* _tmp60_;
			gchar* s = NULL;
			_tmp60_ = g_strdup (s_collection[s_it]);
			s = _tmp60_;
			{
				const gchar* _tmp61_;
				_tmp61_ = s;
				record_script (_tmp61_);
				_g_free0 (s);
			}
		}
	}
	_tmp62_ = opt_devices;
	_tmp62__length1 = _vala_array_length (opt_devices);
	_tmp63_ = _tmp62_[0];
	_tmp64_ = opt_devices;
	_tmp64__length1 = _vala_array_length (opt_devices);
	execvp (_tmp63_, _tmp64_);
	_tmp65_ = opt_devices;
	_tmp65__length1 = _vala_array_length (opt_devices);
	_tmp66_ = _tmp65_[0];
	_tmp67_ = errno;
	_tmp68_ = g_strerror (_tmp67_);
	exit_error ("Cannot run program %s: %s", _tmp66_, _tmp68_, NULL);
	result = 0;
	_g_free0 (preload);
	_g_option_context_free0 (oc);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return _vala_main (argv, argc);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



